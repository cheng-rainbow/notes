![image-20250224113745904](./../../笔记图片/image-20250224113745904.png)

## 一、存储引擎

### 1. 讲一讲mysql的引擎吧，你有什么了解？

MySQL 的存储引擎（Storage Engine）是 MySQL 数据库的核心组件之一，它负责处理数据的存储、检索和更新等底层操作。

1. InnoDB：InnoDB是MySQL的默认存储引I擎，具有**`ACID事务支持`**、**`行级锁`**、**`外键约束`**等特性。它适用于高并发的读写操作，支持较好的数据完整性和`并发控制（MVCC）`。
2. MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量读操作的场景。然而，MyISAM**不支持事务**、**行级锁**和**外键约束**，因此在并发写入和数据完整性方面有一定的限制。
3. Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持**事务**、**行级锁**和**外键约束**。



### 2. MySQL为什么InnoDB是默认引擎？

简单来说，InnoDB 是一个“全能选手”

- **功能全面**: 事务、外键、行级锁等特性让它适合各种应用。
- **可靠性高**: 崩溃恢复能力确保数据安全。
- **性能均衡**: 在读写混合、高并发场景下表现更好。



### 3. InnoDB 和 MyISAM 有什么区别

| 特性     | InnoDB                                     | MyISAM                                                       |
| -------- | ------------------------------------------ | ------------------------------------------------------------ |
| 聚簇索引 | 支持，主键是聚簇索引，叶子节点存储整行数据 | 不支持，所有索引是非聚簇索引，叶子节点存储数据指针（行偏移量） |
| 锁粒度   | 行级锁（支持更高的并发）                   | 表级锁（并发性能较差）                                       |
| 事务     | 支持（ACID 特性）                          | 不支持                                                       |
| 回滚     | 支持（通过 undo log）                      | 不支持                                                       |
| MVCC     | 支持多版本并发控制                         | 不支持                                                       |



### 4. 三层B+树最多存储多少行数据

对于非叶节点存储的是一个键值（4字节）和指针（6字节），一个节点是一页16KB，16KB可以存储 16 KB / 10 B = 1600 个索引键值+指针，那么第二层可以存储 1600 * 1600 = 2 560 000 左右个指针。

对于叶节点，一页可以存储 16KB / 一行字节数，这里我们以 1024 B举例，16 KB / 1024B = 16。

最后 2560 000 * 16 = 40 960 000



## 二、索引

### 1. 索引是什么？有什么好处？

索引（Index）是数据库中一种用于**加速数据检索**的数据结构。它类似于书的目录，通过索引，数据库可以在不扫描整个表的情况下快速定位到需要的数据。



### 2. 讲讲索引的分类是什么？

按功能性分类: **主键索引、唯一索引、普通索引、前缀索引**

按**存储方式**分类 : **聚簇索引（主键索引）、二级索引（辅助索引）**。（B+树）

按数据结构分类: **B+tree索引、Hash索引（innoDb不支持）、Full-text索引**



### 3. 聚簇索引和非聚簇索引

聚簇索引：聚簇索引的 `叶子节点` 存储的是**整行数据**。

非聚簇索引：非聚簇索引的 `叶子节点` 存储的是**索引键值（value）和 主键值**，而不是整行数据。



### 4. MySQL主键是聚簇索引吗？

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引l:

- 如果有主键，默认会使用主键作为**聚簇索引**l的索引键（key）;
- 如果没有主键，就选择第一个不包含NULL 值的**唯一列**作为聚簇索引I的索引键（key）;
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增id 列作为聚簇索弓l的索引键（key）；



### 5. 什么是回表？以及为什么回表

回表是在数据库查询过程中，当使用**非聚簇索引**找到目标数据的主键值（或数据位置）后，需要再次访问表的数据（通常是聚簇索引）以获取完整行数据的操作。



1. 非聚簇索引的设计是为了节省空间和提高灵活性，它只存部分信息（索引键值和主键值）。

2. 当查询涉及表中其他列（不在索引中）时，数据库需要拿着主键值去“原始数据”中取完整记录。



### 6. 什么是覆盖索引？

覆盖索引（Covering Index）是指在数据库查询中，**索引本身包含了查询所需的所有列数据**，从而无需回表（即无需访问表的数据本身）就能直接返回结果的一种优化技术。

 

### 7. 表中十个字段，你主键用自增ID还是UUID，为什么？

用的是自增 id。

1. **存储效率高**：
   - 自增ID（INT 4 字节或 BIGINT 8 字节）比 UUID（字符串 36 字节或二进制 16 字节）占用空间小。
   - 在 InnoDB 中，聚簇索引和二级索引都包含主键值，键值字节数越少，存储越高效，字段多时节省空间更明显。
2. **索引性能好**：
   - 自增ID 是顺序增长的，插入时按顺序写入 B+树索引，减少页面分裂和碎片。
   - UUID 是随机的，插入会导致 B+树频繁分裂，索引效率低。



### 8. 如何选出非叶节点的值

**非叶节点的值** 是由插入操作和 **节点分裂** 过程中逐渐决定的。下面详细讲解这个过程：

假设我们正在插入数据，并且某个叶子节点满了。插入后，这个节点会分裂为两个节点。分裂后的过程如下：

- 在分裂时， 中间的值会被抬升到父节点
  - **例如**：假设叶子节点存储的数据是 `[1, 3, 5, 7, 9]`，当插入 `6` 时，叶子节点会分裂为 `[1, 3, 5]` 和 `[6, 7, 9]`。
  - 然后， **中间值 5** 被 **抬升到父节点**。这样，父节点就包含了一个新的索引值 5，指向这两个子节点 `[1, 3, 5]` 和 `[6, 7, 9]`。
  - 如果父节点也满了，父节点会 **继续分裂**，并且中间值会继续被抬升到更高的层级。

![image-20250221160403285](./../../笔记图片/image-20250221160403285.png)



### 9. B+树的特点是什么

1. **平衡性**
   - 所有叶子节点的高度相同，意味着B+树是一个高度平衡的树结构。所有的插入和删除操作都会通过重新平衡树来维持这个特性，确保查找、插入和删除操作的时间复杂度为 O(log N)。

2. **节点结构**

   - **非叶节点**：内节点只存储键值（key），不存储数据。这些键值用于指导查找的路径。（B树的内节点存储数据）

   - **叶节点**：叶节点不仅存储键值，还存储对应的数据记录（或数据块的指针）。（B树的叶节点存储数据）

3. **链表链接的叶节点**
   - B+树的叶节点通过链表连接在一起，通过链表可以快速地访问相邻的叶节点，这也使得B+树非常适合范围查询（例如，查找某个范围内的所有数据），而无需重新遍历整个树。

4. **插入与删除操作**

   - 插入操作会在叶节点进行，并可能引发节点分裂（如果节点已满），分裂后的新节点会向父节点传播，从而保持树的平衡。

   - 删除操作可能导致节点合并（如果节点中数据过少），同样需要通过父节点的调整来保持平衡。



### 10. MySQL索引为什么用B+树？而不是B树

1. 在B+树中，数据都存储在叶子节点上，而非叶子节点只存储索引信息，非叶子节点可以存储更多的键值，这意味着B+树的的高度更低，查询效率高；而B树的非叶子节点既存储索引信息也存储部分数据，非叶子节点可以存储的键值变少，树的高度变高，查询效率低。

2. B+树的叶子节点使用链表相连，便于范围查询和顺序访问，比如一旦找到范围的起点，就可以顺序遍历链表，无需回溯或额外跳转；B树的叶子节点没有链表连接，范围查询效率低。

3. B+树的查找性能更稳定，每次查找都需要查找到叶子节点；而B树的查找可能会在非叶子节点找到数据，性能相对不稳定。



### 11. 联合索引

使用`联合索引`时，存在`最左匹配原则`，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果**不遵循「最左匹配原则」**，联合索引会**失效**，这样就无法利用到索引快速查询的特性了。

联合索引是（a，b，c）(abc都是字段)，where 条件是 a = 1 and c = 2。此时 a 可以用到索引，筛选出满足 a = 1的数据，但是 c 不可以用到这个联合索引，因为不满足最左匹配原则(缺少b的条件)。



### 12. 哪些情况会导致索引失效

**1. 不满足最左前缀原则（联合索引）**

```sql
CREATE INDEX idx_abc ON test(a, b, c);
SELECT * FROM test WHERE b = 1 AND c = 2; -- 索引失效
SELECT * FROM test WHERE a = 1 AND c = 2; -- 只用到了 a，c 失效
```

2. **在 WHERE 或 ON 中对索引列应用函数、运算符等。**

```sql
CREATE INDEX idx_name ON users(name);
SELECT * FROM users WHERE UPPER(name) = 'ZHANG'; -- 索引失效
SELECT * FROM users WHERE name + 1 = 2; -- 索引失效
```

3. **使用 LIKE 通配符前缀**

```sql
CREATE INDEX idx_name ON users(name);
SELECT * FROM users WHERE name LIKE '%son'; -- 索引失效
```

4. **查询条件中的值类型与索引列类型不一致，导致隐式转换。**

```sql
CREATE INDEX idx_id ON users(id); -- id 是 INT
SELECT * FROM users WHERE id = '1'; -- 索引可能失效
```

5. **OR 连接的条件中，某些列没有索引**

```sql
CREATE INDEX idx_a ON test(a);
SELECT * FROM test WHERE a = 1 OR b = 2; -- 索引可能失效
```

6.  **使用 != 或 <> 操作符**

```sql
CREATE INDEX idx_age ON users(age);
SELECT * FROM users WHERE age != 20; -- 索引可能失效
```



判断索引是否失效

```sql
EXPLAIN SELECT * FROM users WHERE UPPER(name) = 'ZHANG';
```



### 13. 索引的优缺点？

索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：

- 需要占用物理空间，数量越大，占用空间越大;
- `创建`索引和`维护`索引要耗费时间，这种时间随着数据量的增加而增大;
- `会降低表的增删改的效率`，因为每次增删改索引l，B+树为了维护索引有序性，都需要进行动态维护。



### 14. 怎么决定建立哪些索引?

- `排序或分组的列`若有索引，可避免额外排序操作。
- 经常出现在 `WHERE 子句`中的列是索引的首要候选。
- 业务上要求唯一性的列（如 username）需加唯一索引。



### 15. 索引优化详细讲讲

1. **前缀索引优化**：优化长字符串查询，平衡选择性与空间。
2. **覆盖索引优化**：减少回表，提升查询效率。
3. **防止失效优化**：避免函数、类型转换、不合理条件，确保索引被正确利用。



### 16. 什么是前缀索引

前缀索引是专门针对**较长的字符串列**（如 VARCHAR、TEXT 等）设计。它通过只索引字符串的前几个字符（前缀）来减少索引的大小和维护成本，同时仍能加速查询。



## 三、事务

**事务（Transaction）** 是一个逻辑工作单元，它由一组数据库操作（如插入、更新、删除、查询等）组成，这些操作要么`全部成功执行并提交，要么全部失败并回滚`。

### 1. 事务的特性是什么？如何实现的？(`ACID, MVCC`)

事务的特征：

1. **原子性（Atomicity）**
   - **定义**：事务中的所有操作要么全部完成，要么全部不完成，不会出现部分执行的情况。
   - **例子**：转账操作中，从账户 A 扣款和向账户 B 加款必须同时成功或同时失败。
   - **实现/保证**：MySQL 使用 Undo Log 记录当前 SQL 语句的上一个语句成功的执行状态。果在执行当前 SQL 语句失败后，就可以通过 Undo log 来回滚到 SQL 语句执行前的状态.
2. **一致性（Consistency）**
   - **定义**：数据库必须从一个有效状态转换到另一个有效状态的能力，确保数据的正确性和完整性不会因为事务的执行而遭到破坏。
   - **例子**：转账后，账户 A 和 B 的总金额保持不变。
   - **实现/保证**：结合**重做日志Redo Log** 和 **回滚日志Undo Log**，确保数据库启动时可以通过重做日志来重新执行已经提交的事务，将数据恢复到正确的状态 和 事务执行过程中发生错误或需要回滚时，撤销已经执行的操作。通过**MVCC**为每个事务提供一个数据的一致性视图，确保不受其他事务的影响，从而实现了事务的一致性。 比如，不能插入重复的主键值，事务中途失败也不会留下不一致的中间状态。
3. **隔离性（Isolation）**
   - **定义**：事务内部的操作与其他事务是隔离的，并发过程中的各个事务之间不能互相干扰。
   - **例子**：事务 A 在修改数据时，事务 B 看不到未提交的修改。
   - **实现/保证**：InnoDB 使用`锁`（行锁、表锁）和 `MVCC` 实现隔离。`MVCC` 通过保存数据的历史版本（基于 Undo Log），让事务读取一致的快照，默认隔离级别是可重复读，避免脏读和不可重复读。`锁机制`则防止并发冲突，比如更新时加排他锁。
4. **持久性（Durability）**
   - **定义**：事务一旦提交，其修改的数据将永久保存，即使系统崩溃也不会丢失。
   - **例子**：转账完成后，数据写入磁盘，即使断电也能恢复。
   - **实现/保证**：**Redo log 是一种预写式日志（write-Ahead Log）**，它记录的是在某个数据页上做了什么修改。当有记录需要更新时，InnoDB 引擎会先把记录写到 redo log 中，在系统空闲时，再将操作记录更新到磁盘中。（为了实现快速读写数据，我们会在内存中设置一个 Buffer pool 缓冲池，数据库可以直接与 Buffer Pool 进行读取交互，定期再将 Buffer Pool 数据存储到磁盘中。）

多版本并发控制（Multi-Version Concurrency Control，简称 MVCC）是一种数据库管理系统中常用的并发控制机制，它通过为数据维护多个版本(当一个事务修改数据时，不是直接覆盖原来的数据，而是创建一个新版本，老版本的数据仍然保留)，使得**读操作和写操**可以并行执行，从而减少锁的使用，提升系统的吞吐量。



### 2. mysql可能出现什么和并发相关问题？

1. **脏读** : 一个事务读取了另一个未提交事务修改的数据，如果未提交事务回滚，读取到的数据就变成了“脏数据”。（读取未提交的数据）
2. **不可重复读 ** : 一个事务在多次读取同一数据时，由于另一个事务提交了修改，导致读取结果不一致。（读取已提交的数据）
3. **幻读**  : 一个事务在多次查询某个范围的数据时，由于另一个事务插入或删除了行，导致查询结果集的行数发生变化（如同“幻觉”）。



### 3. mysql 的隔离级别有哪些

1.  **读未提交** : 事务可以读取另一个未提交事务的修改数据。（什么并发问题都没解决）
2. **读已提交** : 事务只能读取已提交的数据，解决了脏读问题。
3. **可重复读** : 事务内多次读取同一数据结果一致，解决了不可重复读。（默认隔离级别）
4. **串行化** : 事务完全隔离，串行执行，解决了所有并发问题（脏读、不可重复读、幻读）。

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 可能   | 可能       | 可能   |
| 读已提交 | 不可能 | 可能       | 可能   |
| 可重复读 | 不可能 | 不可能     | 可能   |
| 串行化   | 不可能 | 不可能     | 不可能 |



### 4. InnoDB 如何在可重复读级别防止幻读？

在InnoDB存储引擎中，默认情况下是可重复隔离级别，在此基础上，我们可以通过InnoDB提供的 `Next-Key Lock` 来保证了不会出现幻读的问题。

`Next-Key Lock` 是**行锁**和**间隙锁**的结合，并且只在可重复读（Repeatable Read）和更严格的隔离级别下生效。`SELECT * FROM test WHERE id > 5 FOR UPDATE;`

正常的读操作读到的是MVCC的快照，在当前事务中多次查询时，其他事务添加了满足条件的数据会导致幻读

**加锁的读操作读的也是MVCC，但是会对读的所有行加上 Next-Key Lock 锁，保证事务无法插入新的行，实现了可重复读级别下防止幻读**



| 隔离级别 | 普通读是否加锁 | 普通读是否使用 MVCC | 写操作自动加锁类型              | 范围查询加锁类型 | 解决的问题             |
| -------- | -------------- | ------------------- | ------------------------------- | ---------------- | ---------------------- |
| 读未提交 | 否             | 否                  | X Lock（行锁）                  | 无范围锁         | 无                     |
| 读已提交 | 否             | 是                  | X Lock（行锁）                  | 无范围锁         | 脏读                   |
| 可重复读 | 否             | 是                  | X Lock / Next-Key Lock / 意向锁 | Next-Key Lock    | 脏读、不可重复读       |
| 串行化   | 是（S Lock）   | 否                  | X Lock / Next-Key Lock / 意向锁 | Next-Key Lock    | 脏读、不可重复读、幻读 |



### 5. 介绍一下MVCC实现原理

**MVCC（多版本并发控制，Multi-Version Concurrency Control）** 是数据库中一种常见的**并发控制机制**，用于在**多事务环境下**提高并发性能，同时保证**事务隔离性**。

- **核心思想**：
  - MVCC 通过为数据记录维护多个版本，使得事务可以读取某个时间点的数据快照，而不需要等待其他事务完成修改。
  - 每个事务看到的数据版本取决于其隔离级别和开始时间。



### 6. 一条update是不是原子性的？为什么？

在 InnoDB 中，**即使没有显式使用 BEGIN，每条独立的 DML 语句**（**INSERT**、**UPDATE**、**DELETE**）**都会自动开启一个隐式事务**（只针对写操作），并在语句完成后自动提交（autocommit=1 时），将修改永久写入数据库。（在 InnoDB 中，对数据库的增删改（DML）操作本质上都基于事务，都满足事务的核心特征ACID）



在执行 UPDATE 时，InnoDB 先将旧值写入 Undo Log（回滚日志），如果操作失败，可以根据 Undo Log 恢复到原始状态。

在提交前，InnoDB 将修改写入 Redo Log（重做日志），如果系统崩溃，恢复时通过 Redo Log 重做已提交的更改。

UPDATE 时，InnoDB 对目标行加排他锁，防止并发事务干扰，确保操作要么完整执行，要么不执行。



### 7. 一个事务包含大量 SQL 的弊端

1. **锁持有时间过长** : SQL 语句越多，事务执行时间越长，锁的持有时间也随之延长，直到事务提交（COMMIT）或回滚（ROLLBACK）。

2. **性能瓶颈** : 每条写操作生成 Undo Log（回滚日志）和 Redo Log（重做日志），大量 SQL 导致日志量激增，增加 I/O 负担。

3. **死锁风险增加** : 事务涉及多个表或多行，锁范围扩大。多个长事务交叉访问相同资源，形成循环等待。

4. **回滚成本高** : 事务失败时，InnoDB 根据 Undo Log 回滚所有操作。



## 四、锁

### 1. 锁的分类

1. **按照颗粒度划分**：**全局锁（对整个数据库加锁）**，**表锁（Table Lock）**，**行锁（Row Lock）**
2. **按锁的功能**：
   - **共享锁（Shared Lock，S Lock）读锁**：允许多个事务同时读取数据，但禁止任何事务对数据写操作。
   - **排他锁（Exclusive Lock，X Lock）写锁**：独占数据，禁止其他事务读写。

1. **`表级锁`**
   - **读锁 (Read Lock)**：读锁允许当前事务和其他事务同时读取表中的数据，但禁止任何事务对表进行写操作。
   - **写锁 (Write Lock)**：写锁独占整个表，只有持有写锁的事务可以读写表，其他事务无法访问（读写都被阻塞）。
   - **意向锁 (Intention Lock)**：意向锁是表级锁的一种，表示事务打算对表中的某些行加锁的意图。仅在InnoDB中与行级锁配合

2. **`行级锁`**（按照锁的范围）

   - **记录锁（Record Lock）**：锁定单个索引记录，防止其他事务修改或锁定该行。（基于索引实现）
   
   
      - **间隙锁（Gap Lock）**：锁定索引记录之间的“间隙”，防止新行插入（幻读）。常用于范围查询。
   
   
      - **Next-Key Lock（临键锁）**：InnoDB 默认的行锁方式，结合记录锁和间隙锁，锁定某行及其前面的间隙。
   

### 2. 自动加锁

自动加**表锁**: 

1. 不直接加传统表锁（读锁/写锁），但会加意向锁 (IS/IX)。

2. InnoDB的行锁是针对于索引加的锁，**不通过索引条件检索数据**，那么lnnoDB将对表中的所有记录加锁，此时就会升级为表锁。比如下面update,delete如果不是通过索引加的锁，会**`升级为表锁`**。

自动加**行锁**: 

1. 修改操作（INSERT、UPDATE、DELETE）自动加排他行锁（多个满足条件的行）。普通 SELECT 不加锁（基于MVCC），除非显式锁语句加共享或排他行锁。
2. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为**行级锁**。

![image-20250227110536624](./../../笔记图片/image-20250227110536624.png)



### 3. 手动加锁

**表级锁**: 通过 `LOCK TABLES` 语句显式加锁（MyISAM 和 InnoDB 都支持）。

**行级锁**: 通过 `SELECT ... FOR UPDATE` (排他锁)或 `SELECT ... LOCK IN SHARE MODE` (共享锁 )加锁（仅 InnoDB 支持）

手动加锁一般在事务中使用，通过在事务开始后使用这些行锁，能够保证在**整个事务执行期间**，对锁定的行数据的操作是在一个完整的、不受其他事务干扰的环境中进行。

理论上也可以不在事务中使用手动行锁，但这种情况很少见且可能会带来一些问题。如果不放在事务中，那么行锁的作用范围就**只限于当前**的单个语句执行期间，语句执行完锁就会释放，无法保证后续操作与当前操作之间的数据一致性，也无法利用事务的回滚等机制来处理可能出现的错误。



### 4. MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？

**通常会发生阻塞**。这是因为 InnoDB 使用行锁（Row Lock）来管理并发访问，而 UPDATE 操作会为目标行加**排他锁（X Lock）**，同一时刻只有一个线程能持有该锁，其他线程需要等待。



### 5. 如果两个线程的 UPDATE 语句涉及的范围条件不是索引，是否会发生阻塞

- **无索引场景**：两个线程的 UPDATE 范围即使不同，也**会因全表锁而阻塞**。
- **有索引场景**：仅当范围重叠涉及相同行时才会阻塞。



### 6. 锁跟索引有什么关系？

InnoDB 的锁是基于索引实现的，索引决定了锁的粒度和范围。

查询条件基于索引时 ，锁精确到行或范围；不基于索引或无索引时，退化为表锁。



## 五、日志

`Buffer Pool` 是 MySQL 中用于缓存数据的内存区域，它存储数据库中读取的 **数据页**，数据页被修改后称为 **脏页（Dirty Page）**，需要刷新到磁盘。InnoDB 引擎会在适当的时候，将缓存在 Buffer Pool 的脏页刷新到磁盘里



`binlog` 是一个日志文件，用于记录所有对数据库执行的修改操作。在主服务器上执行的所有数据修改操作都会记录到 binlog 中。

- **数据恢复**：可以用来恢复数据库到某个时间点。

- **主从复制**：从服务器读取主服务器的 binlog 文件，执行相同的操作，保持数据一致性。



`undo log` 是 MySQL 中用于 **事务回滚** 的日志，它记录了事务操作之前的数据状态，以确保在事务失败或回滚时能够将数据恢复到之前的状态。

- **事务回滚**：Undo Log 记录了每个事务对数据的修改之前的状态，当事务回滚时，可以通过 Undo Log 将数据库恢复到事务执行之前的状态。
- **MVCC（多版本并发控制）**：Undo Log 还用于实现 MVCC，使得 MySQL 能够在高并发情况下，提供一致性视图，支持事务隔离级别，避免读写冲突。



`redo log` 是用于 **重写日志**，主要用于保证 **事务的持久性**，即确保即使系统崩溃，已经提交的事务数据不会丢失。

- **保证事务的持久性**：即使数据库崩溃，也能通过 redo log 恢复已经提交的事务数据。

- **崩溃恢复**：当 MySQL 重启时，使用 redo log 来恢复未完全持久化到磁盘的数据。



## 六、性能调优

使用 `EXPLAIN` 是调优 SQL 查询性能的一个重要手段。`EXPLAIN` 命令可以帮助你分析 SQL 查询的执行计划，从中发现性能瓶颈并进行相应的优化。

### 1. **使用 `EXPLAIN`**

`EXPLAIN` 命令可以用来查看查询执行计划，输出会显示 MySQL 如何执行查询，包括表的访问顺序、索引的使用情况、数据扫描类型等。

**基本语法：**

```sql
EXPLAIN SELECT * FROM your_table WHERE column = 'value';
```

你也可以用 `EXPLAIN` 查看 `JOIN` 查询的执行计划：

```sql
EXPLAIN SELECT * FROM table1 t1
JOIN table2 t2 ON t1.id = t2.id
WHERE t1.name = 'example';
```

### 2. **`EXPLAIN` 输出解析**

`EXPLAIN` 输出包含以下几列，每一列的意义都能够帮助我们诊断查询性能问题：

| 字段            | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| **id**          | 查询的标识符，标识执行计划中的每个步骤。`id` 越小的步骤越先执行。 |
| **select_type** | 查询的类型，常见的类型包括：                                 |

- `SIMPLE`：简单查询，不包含子查询。

- `PRIMARY`：最外层的查询。

- `UNION`：联合查询。

- `SUBQUERY`：子查询。

- `DEPENDENT SUBQUERY`：依赖外部查询的子查询。

- **table** | 查询的表或视图的名称，显示当前操作的是哪个表。

- type

   | 连接类型或访问类型，是最重要的性能指标之一。常见类型从高效到低效依次是：

  - `ALL`：全表扫描，通常是最慢的。
  - `index`：索引扫描，较快。
  - `range`：范围扫描，扫描索引中的一部分。
  - `ref`：通过索引查找单一匹配的记录。
  - `eq_ref`：每个行的索引查找，通常是连接时最优的方式。
  - `const`、`system`：常数表，最快的访问方式。

- **possible_keys** | 查询时 MySQL 认为可能使用的索引列表。

- **key** | 实际使用的索引。

- **key_len** | 使用索引时，索引的长度。值越大表示索引使用越充分。

- **ref** | 表示哪些列或常数与索引匹配。

- **rows** | 估算需要扫描的行数，越小越好。

- **filtered** | 过滤掉的行的百分比，通常越小越好。

- Extra

   | 提供关于查询执行的额外信息。常见的值包括：

  - `Using index`：表示查询只使用了索引而没有访问数据行。
  - `Using where`：查询通过 `WHERE` 子句过滤了数据。
  - `Using temporary`：使用了临时表（通常意味着查询不够高效）。
  - `Using filesort`：表示需要排序操作，可能会影响性能。

### 3. **调优策略**

通过分析 `EXPLAIN` 输出，你可以针对以下几个方面进行 SQL 调优：

#### 3.1 **避免全表扫描（ALL）**

- **问题**：`ALL` 表示全表扫描，是最慢的查询方式。查询性能瓶颈通常发生在全表扫描时，尤其是表的行数非常大时。
- **优化方法**：检查是否有合适的索引可以避免全表扫描。使用 `WHERE` 子句的列创建索引。

#### 3.2 **确保索引的使用（key）**

- **问题**：`EXPLAIN` 中的 `key` 列显示的是查询实际使用的索引。如果没有使用索引，查询会变得非常慢。

- 优化方法

  ：

  - 确保在 `WHERE`、`JOIN` 和 `ORDER BY` 子句中涉及的列上创建了索引。
  - 检查 `EXPLAIN` 输出中的 `possible_keys` 列，看看是否有适合的索引可用。

#### 3.3 **优化连接类型（type）**

- **问题**：`EXPLAIN` 中的 `type` 显示的是查询的连接类型。如果是 `ALL`，表示可能需要做全表扫描，性能较差。`range`、`ref` 和 `eq_ref` 通常是较优的连接类型。

- 优化方法

  ：

  - 确保连接条件的列上有索引。
  - 尽量避免不必要的表连接，使用更高效的连接条件。

#### 3.4 **避免临时表（Using temporary）**

- **问题**：当 `EXPLAIN` 输出中出现 `Using temporary` 时，表示查询使用了临时表来存储中间结果，这通常会导致性能下降。

- 优化方法

  ：

  - 尽量避免在查询中使用 `GROUP BY` 或 `ORDER BY`，如果可能，减少排序和分组的字段。
  - 优化查询，减少不必要的 `JOIN` 或 `GROUP BY` 操作。

#### 3.5 **避免文件排序（Using filesort）**

- **问题**：当 `EXPLAIN` 输出中包含 `Using filesort` 时，表示 MySQL 必须进行额外的排序操作，可能会消耗大量的 CPU 和磁盘 I/O。

- 优化方法

  ：

  - 确保 `ORDER BY` 子句中的列上有索引，尤其是 `ORDER BY` 使用的列。
  - 如果是多列排序，尝试将排序的列都包括在索引中。

#### 3.6 **减少返回的行数（rows）**

- **问题**：`EXPLAIN` 中的 `rows` 列显示了 MySQL 扫描的预估行数。如果行数过多，表示查询会扫描大量数据，可能会导致性能问题。

- 优化方法

  - 优化查询条件，尽量减少扫描的行数。
- 对查询进行分页或限制返回的记录数（如使用 `LIMIT`）。



