## 一、内存模型

### 1. JVM的内存模型介绍一下

JVM运行时内存共分为**程序计数器**，**虚拟机栈**、**堆**、**方法区**、**本地方法栈**五个部分。还有一部分内存叫**直接内存**，属于操作系统的本地内存，也是可以直接操作的。



### 2. JVM内存模型里的堆和栈有什么区别？

**存储内容**：堆主要负责存储程序运行时动态创建的数据，包括**对象实例、数组**。而栈则是**每个线程私有的内存区域**，主要用来**存储局部变量**（比如方法内的基本类型变量或对象引用）和**方法调用**相关的信息（比如方法参数、返回地址等）。

**线程可见性**：堆是**所有线程共享的内存区域**，意味着多个线程可以同时访问堆中的对象，这也使得堆中的数据需要额外的同步机制来避免竞争问题。相比之下，栈是线程**私有的**，**每个线程都有自己的栈**，线程之间互不干扰，因此栈中的数据天然具有线程安全性。

**内存管理**：当程序需要创建对象时，JVM会在堆中分配空间，这些内存由**垃圾回收机制（GC）**负责管理，回收不再使用的对象。而栈的内存管理则更加简单，它采用静态分配的方式，**按照方法调用的顺序自动创建和销毁栈帧**，方法执行结束时内存会自动回收，无需GC介入。



### 3. 栈中存的到底是指针还是对象？

在JVM的栈（Stack）中，对于**基本类型的变量**，存储的是值本身，对于**引用类型的变量**，存储的并不是对象本身，而是**对象的引用（Reference）**，可以理解为指向堆中对象的“指针”。对象本身始终存储在堆（Heap）中。



### 4.堆分为哪几部分呢？

在JVM（Java虚拟机）的内存模型中，**堆（Heap）**是用于存储对象实例和数组的主要区域。 JVM的堆通常分为两大主要区域：

- **年轻代（Young Generation）**：存放新创建的对象，回收频率较高。
- **老年代（Old Generation）**：存放存活时间较长的对象，回收频率较低。



(1) **`年轻代 (Young Generation)`**

年轻代是堆的一部分，用于存放新创建的对象。由于大多数对象生命周期较短，年轻代设计为频繁进行垃圾回收（称为Minor GC）。年轻代又细分为以下三个区域：

- **Eden区（Eden Space，伊甸园区）**：
  - 作用：所有新创建的对象首先分配在Eden区。
  - 特点：Eden区占年轻代的大部分空间（通常比例为8:1:1，与两个Survivor区相比）。
  - 回收：当Eden区满时，触发Minor GC，对象存货次数达到阈值后会被转移到Survivor区。
- **Survivor区（Survivor Space，幸存区）**：
  - 分为两个子区域：**From Survivor** 和 **To Survivor**。
  - 作用：保存经过Minor GC后仍存活的对象，作为Eden区和老年代之间的缓冲。
  - 特点：
    - 两个Survivor区大小相等，且总是只有一个处于使用状态。
    - From区存活的对象会在Minor GC时被复制到To区，之后From和To角色互换。
  - 目的：通过复制算法减少内存碎片，并筛选出存活较久的对象。

(2) **`老年代 (Old Generation)`**

- 作用：存放经过多次Minor GC仍存活的对象，或者大对象（超过一定阈值直接分配到老年代）。
- 特点：
  - 占堆的大部分空间（通常是年轻代的2倍或更多）。
  - 回收频率低，垃圾回收称为Major GC或Full GC。
- 回收：老年代通常使用标记-清除或标记-整理算法，效率低于年轻代的复制算法。



(3) **`字符串常量池 (String Pool)`**（JDK 8及之后）：在JDK 8及之后，字符串常量池从方法区（永久代）迁移到堆中，成为堆的一个逻辑部分。存储字符串字面量（如"hello"）和通过String.intern()放入的字符串。

(4) **`大对象区`**：一些JVM实现中，大对象（如超大数组）可能直接分配到老年代，避免频繁复制。



### 5. 程序计数器的作用，为什么是私有的？

Java 程序具备支持多线程并发运行的能力。在多线程共同运行的情况下，CPU 会给各个线程分配时间片。举例来说，cpu会先给线程 1 分配一个时间片，线程 1 便开始执行代码。倘若在这个时间片内，线程 1 的代码尚未执行完毕，系统就会将线程 1 当前的执行状态进行暂存，随后切换到线程 2。此时，线程 2 开始执行它的代码，当线程 2 执行到一定阶段，且它所分配到的时间片耗尽后，系统又会切换回线程 1，继续执行之前暂存状态下线程 1 尚未完成的剩余代码。

在这个线程切换的过程中，cpu需要知道当前线程下一条指令将在何处开始执行？这就必然会用到程序计数器。每个线程都拥有属于自己的程序计数器，这是因为各个线程所执行代码的指令地址各不相同。所以，每个线程都必须配备独立的程序计数器。