**设计原则**是高层指导，**设计模式**是具体实现。**设计模式**是在**设计原则**指导下发展出来的。换句话说，设计模式是原则的具体化体现。

## 一、UML

### 1. 类图

UML类图是一个矩形框，分为三部分，上中下分别表示：`类名`，`属性（成员变量）`，`操作（方法）`

```uml
+---------------------------+
|    Person      		    |
+---------------------------+
| - name: String  			|
| - age: int      			|
+---------------------------+
| + getName(): String 		|
| + setAge(int age): void  |
+---------------------------+
```

属性和操作名前面的符号表示这个属性或操作的可见性

`+` 表示 public，`-` 表示 private，`#` 表示 protected, 还有默认



属性格式: `可见性` `名称:` `类型` `[默认值]`，如 - name: String。

方法格式: `可见性` `名称(参数列表):` `[返回类型]`，如 + setName(int name): String。



### 2. 类与类之间的关系

#### 2.1 **`依赖`关系**

表示一个类临时使用另一个类，通常通过方法参数、局部变量或静态调用。是最弱的关系，生命周期无关。

表示方式：**虚线箭头**指向被依赖的类。

```java
class Payment {
    public void pay() {
        System.out.println("Paid.");
    }
}

class Order {
    public void processPayment(Payment payment) {
        payment.pay();  // 临时依赖 Payment
    }
}
Order --> Payment
```

#### 2.2 **`关联`关系**

表示两个类之间存在某种联系，通常是“使用”或“知道”的关系，是是最基础、最松散的关系。

表示方式：用**实线**连接两个类，带**箭头**的是双向关联，不带箭头的是单向关联（指向被关联的类）. 

```java
class Person {
    private List<Car> cars;  
    public void addCar(Car car) {
        cars.add(car);
    }
}

class Car {
}
Person —> Car
```

#### 2.3 **`聚合`关系**

一种特殊的关联，表示 **“整体-部分”** 关系，但**部分可以独立于整体存在**，是一种“has-a”关系，整体不控制部分的生命周期。

表示方式：用**实线**连接两个类，但是用**空心菱形**指向整体

```java
class University {
    private List<Department> departments;

    public void addDepartment(Department dept) {
        departments.add(dept);
    }
}

class Department {
    // 无需持有 University 的引用
}
Department -◇ University
```

#### 2.4 **`组合`关系**

更强的 **“整体-部分”** 关系，**部分随整体的销毁而销毁**。也是一种“has-a”关系，但整体控制部分的生命周期。

表示方式：用**实线**连接两个类，但是用**实心菱形**指向整体

```java
class House {
    private List<Room> rooms;

    public House() {
        rooms = new ArrayList<>();  // Room 在 House 中创建
        rooms.add(new Room());
    }
}

class Room {
    // Room 的生命周期依赖 House
}
Room -◆ House
```

#### 2.5 **`继承`关系**

表示类之间的“is-a”关系，子类继承父类的属性和方法。是面向对象编程的基础特性之一

表示方式：用**实线**连接两个类，**空心三角**指向父类

```java
abstract class Animal {
    protected String species;
    public void move() {
        System.out.println("Moving...");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Woof!");
    }
}
Dog -|> Animal
```

#### 2.6 **`实现`关系**

表示一个类实现某个接口，承诺提供接口定义的行为。是一种“can-do”关系。

表示方式：**虚线**加**空心三角**指向接口。

```java
interface Printable {
    void print();
}

class Printer implements Printable {
    public void print() {
        System.out.println("Printing...");
    }
}
Printer --|> Printable
```



## 一、软件设计原则

### 1. 单一职责原则（SRP）	

**定义**: 一个类应该只有一个职责，或者说只有一个引起它变化的原因。

**核心思想**: 将功能分离，避免一个类承担过多职责。

反面示例：

```java
class User {
    private String name;
    public void saveToDatabase() { /* 数据库操作 */ }
    public void sendEmail() { /* 发送邮件 */ }
}
```

正面示例：

```java
class User {
    private String name;
}

class UserRepository {
    public void saveToDatabase(User user) { /* 数据库操作 */ }
}

class EmailService {
    public void sendEmail(User user) { /* 发送邮件 */ }
}
```



### 2. 开闭原则（OCP）

**定义**：软件实体（类、模块、函数等）应对扩展开放，对修改关闭。

**核心思想**: 通过抽象和多态新增功能，而不是修改现有代码。

反面示例：（胖虎换皮，不同皮肤）

```java
// 每次扩展都需要对原有类PangHu进行修改，修改BlueSkin为OriginSkin
public class PangHu {
    BlueSkin skin;

    public void setSkin(BlueSkin skin) {
    }

    public void display() {
        skin.display();
    }
}

public class PangHu {
    Oringin skin;

    public void setSkin(Oringin skin) {
    }

    public void display() {
        skin.display();
    }
}
```

正面示例：（胖虎换皮，不同皮肤）

```java
// 对修改关闭，不需要修改PangHu类
public abstract class AbstractSkin {

    public abstract void display();
}
public class BlueSkin extends AbstractSkin {
    @Override
    public void display() {
        System.out.println("Blue skin");
    }
}
public class OriginSkin extends AbstractSkin {
    @Override
    public void display() {
        System.out.println("Origin skin");
    }
}
public class PangHu {
    AbstractSkin skin;

    public void setSkin(AbstractSkin skin) {
        this.skin = skin;
    }

    public void display() {
        skin.display();
    }
}

public class Main {
    public static void main(String[] args) {
        PangHu pangHu = new PangHu();
        pangHu.setSkin(new OriginSkin());
        pangHu.display();

        pangHu.setSkin(new BlueSkin());
        pangHu.display();
    }
}
// 输出
Origin skin
Blue skin
```



### 3. 依赖倒置原则（DIP）

**定义**：高层模块不依赖低层模块，二者都依赖抽象；抽象不应该依赖细节，细节依赖抽象。（依赖的高层模块，被依赖的是底层模块，也就是类中的变量是底层模块）

**核心思想**: 通过接口或抽象类解耦，使用依赖注入。

反面示例：

```java
// Computer 直接使用 IntelCpu 和 ShanDiHardDisk。
// 高层模块（Computer）与低层模块（IntelCpu 和 ShanDiHardDisk）紧耦合。
public class IntelCpu {
    private String name;

    public IntelCpu(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
public class ShanDiHardDisk {
    private String name;

    public ShanDiHardDisk(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

// 高层模块直接依赖具体实现，违反 DIP
public class Computer {
    // 直接使用具体类，而不是抽象
    private IntelCpu cpu;
    private ShanDiHardDisk hardDisk;

    public Computer() {
        this.cpu = new IntelCpu("intel");
        this.hardDisk = new ShanDiHardDisk("shanDi");
    }

    public void show() {
        System.out.println("cpu: " + cpu.getName());
        System.out.println("hardDisk: " + hardDisk.getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.show();
    }
}
```

正面示例：

```java
// 高层模块Computer 类依赖抽象（Cpu 和 HardDisk），而不是具体实现（IntelCpu 和 ShanDiHardDisk）。
// 低层模块IntelCpu 和 ShanDiHardDisk 实现接口，通过构造器注入到 Computer。
// 如果需要更换 CPU 或硬盘（比如用 AMDCpu 替换 IntelCpu），只需创建新实现类，无需修改 Computer，符合 DIP。
public interface Cpu {
}
public interface HardDisk {
}
public class ShanDiHardDisk implements HardDisk {
    private String name;

    public ShanDiHardDisk(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
public class IntelCpu implements Cpu{
    private String name;

    public IntelCpu(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
// 高层模块，如果直接使用底层模块，会对修改开放，需要修改Computer类
public class Computer {
	// 底层模块的抽象
    private Cpu cpu;

    private HardDisk hardDisk;

    public Computer(Cpu cpu, HardDisk hardDisk) {
        this.cpu = cpu;
        this.hardDisk = hardDisk;
    }
    public void show() {
        System.out.println("cpu: " + cpu);
        System.out.println("hardDisk: " + hardDisk);
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建一个计算机对象
        Computer computer = new Computer(new IntelCpu("intel"), new ShanDiHardDisk("shanDi"));

        // 显示计算机的配件信息
        computer.show();
    }
}
```

**依赖倒置原则 是实现 开闭原则 的关键手段，开闭原则 是 依赖倒置原则 的应用目标之一。** 所以他们两个的例子基本一样



### 4. 里氏替换原则（LSP）

**定义**: 子类必须能够替换其父类，且不影响程序的正确性。

**核心思想**: 子类可以继承父类的行为，并在必要时扩展功能，但不能改变父类的预期行为

反面示例：

```java
// 父类 Bird 的 fly() 方法预期是鸟儿能飞。
// 子类 Ostrich 重写了 fly()，但完全改变了行为（抛异常），破坏了父类的契约。当 Ostrich 替换 Bird 时，程序出错，违反 LSP。
class Bird {
    public void fly() {
        System.out.println("I can fly!");
    }
} // 鸵鸟
class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("I can't fly!");
    }
}

class Main {
    public static void makeBirdFly(Bird bird) {
        bird.fly();  // 期望鸟儿飞，但 Ostrich 会抛异常
    }

    public static void main(String[] args) {
        makeBirdFly(new Bird());      // 正常
        makeBirdFly(new Ostrich());   // 抛异常，违反 LSP
    }
}
```

正面示例：

```java
// 父类 move() 定义了“移动”的行为，子类 Ostrich 重写为“在地上跑”，仍然符合“移动”的契约。
// 子类替换父类时，程序行为正常，符合 LSP。
class Bird {
    public void move() {
        System.out.println("I can move!");
    }
} // 鸵鸟
class Ostrich extends Bird {
    @Override
    public void move() {
        System.out.println("I can run on the ground!");
    }
}

class Main {
    public static void makeBirdMove(Bird bird) {
        bird.move();  // 无论 Bird 还是 Ostrich，都能正常移动
    }

    public static void main(String[] args) {
        makeBirdMove(new Bird());     // 输出: I can move!
        makeBirdMove(new Ostrich());  // 输出: I can run on the ground!
    }
}
```



### 5. 接口隔离原则（ISP）

**定义**: 客户端不应该被迫依赖它不使用的接口。

**核心思想**: 接口应小而专一，避免“胖接口”。

反面示例：

```java
// Worker 接口包含 eat() 方法，但 RobotWorker 不需要这个功能，却被迫实现。
// 如果 Worker 接口新增方法（如 sleep()），所有实现类都得修改，即使对机器人无意义。
interface Worker {
    void work();  // 工作
    void eat();   // 吃饭
}
class HumanWorker implements Worker {
    public void work() {
        System.out.println("Human working...");
    }

    public void eat() {
        System.out.println("Human eating...");
    }
}
class RobotWorker implements Worker {
    public void work() {
        System.out.println("Robot working...");
    }

    public void eat() {
        // 机器人不吃饭，空实现
        System.out.println("Robot doesn't eat.");
    }
}

public class Main {
    public static void main(String[] args) {
        Worker human = new HumanWorker();
        human.work();
        human.eat();

        Worker robot = new RobotWorker();
        robot.work();
        robot.eat();  // 无意义的调用
    }
}
```

正面示例：

```java
// Workable 和 Eatable 分离，RobotWorker 只实现 Workable，无需处理无关的 eat()。
// 如果新增 Sleepable 接口，只影响需要睡眠的类（如人类），机器人不受影响。
interface Workable {
    void work();
}
interface Eatable {
    void eat();
}
class HumanWorker implements Workable, Eatable {
    public void work() {
        System.out.println("Human working...");
    }

    public void eat() {
        System.out.println("Human eating...");
    }
}
class RobotWorker implements Workable {
    public void work() {
        System.out.println("Robot working...");
    }
    // 不需要实现 eat()
}

public class Main {
    public static void main(String[] args) {
        Workable humanWorker = new HumanWorker();
        humanWorker.work();

        Eatable humanEater = new HumanWorker();
        humanEater.eat();

        Workable robot = new RobotWorker();
        robot.work();  // 机器人只关心工作
    }
}
```





### 6. 最少知识原则（迪米特法则）

**定义**: 一个对象应尽量少了解其他对象的内部结构（“只与朋友说话”）。

**核心思想**: 减少对象间的直接调用，避免链式访问（如 a.getB().getC()）。

方面示例：

```java
// Shop 直接调用 customer.getWallet().getMoney()，深入了解了 Customer 的内部结构（Wallet）。
// 如果 Customer 改成用 BankCard 替代 Wallet，Shop 的代码也要改，耦合性高。
class Wallet {
    private int money;

    public int getMoney() {
        return money;
    }
}
class Customer {
    private Wallet wallet;

    public Wallet getWallet() {
        return wallet;
    }

    public Customer() {
        this.wallet = new Wallet();
    }
}
class Shop {
    public void sell(Customer customer) {
        int amount = customer.getWallet().getMoney();  // 链式调用
        System.out.println("Customer pay: " + amount);
    }
}

public class Main {
    public static void main(String[] args) {
        Customer customer = new Customer();
        Shop shop = new Shop();
        shop.sell(customer);
    }
}
```

正面示例：

```java
// Shop 不再关心 Customer 如何支付（是用 Wallet 还是其他方式），只调用 customer.pay()。
// 如果 Customer 内部实现变化（比如用 BankCard），Shop 无需修改。
class Wallet {
    private int money;

    public int getMoney() {
        return money;
    }
}

class Customer {
    private Wallet wallet;

    public Customer() {
        this.wallet = new Wallet();
    }

    // 增加代理方法，封装内部逻辑
    public int pay() {
        return wallet.getMoney();
    }
}

class Shop {
    public void sell(Customer customer) {
        int amount = customer.pay();  // 只与 Customer 交互
        System.out.println("Customer paid: " + amount);
    }
}

public class Main {
    public static void main(String[] args) {
        Customer customer = new Customer();
        Shop shop = new Shop();
        shop.sell(customer);
    }
}
```





### 7. 合成复用原则

定义: 优先使用组合或聚合而非继承来复用代码。

核心思想: 继承导致紧耦合，组合更灵活。

反面示例：

```java
// Car 继承 Engine，形成“Car 是一种 Engine”的关系，逻辑上不合理（Car 应该“拥有”Engine）。
// 如果 Engine 添加新方法（如 stop()），Car 会无意继承，增加不必要的功能。
// 无法动态更换引擎类型（比如换成电动引擎）。

class Engine {
    public void start() {
        System.out.println("Engine started.");
    }
}
class Car extends Engine {
    public void drive() {
        start();  // 继承来的方法
        System.out.println("Car is driving.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.drive();
    }
}
```

正面示例：

```java
class Engine {
    public void start() {
        System.out.println("Engine started.");
    }
}
class Car {
    private Engine engine;  // 组合关系

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving.");
    }

    // 可动态更换引擎
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}
class ElectricEngine {
    public void start() {
        System.out.println("Electric engine started.");
    }
}

public class Main {
    public static void main(String[] args) {
        Engine gasEngine = new Engine();
        Car car = new Car(gasEngine);
        car.drive();

        // 动态更换引擎
        ElectricEngine electricEngine = new ElectricEngine();
        car.setEngine(electricEngine);
        car.drive();
    }
}
```



## 二、软件(程序)设计模式

Java设计模式是软件开发中解决常见问题的一些经过验证的解决方案，它们是基于面向对象设计原则的最佳实践。设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。

### 1. 创建型模式

创建型模式（Creational Patterns）是设计模式的一种分类，专注于**对象的创建机制**，旨在以合适的方式创建对象，隐藏创建细节，提高代码的灵活性和可复用性。创建型模式的核心思想是将对象的创建与使用分离，让系统更符合“开闭原则”（对扩展开放，对修改关闭）。



#### 1.1 单例设计模式

单例设计模式是说一个类不再提供构造方法，而是通过一个静态方法给外部提供实例，并且这个类只会创建一个实例，当创建过实例后，再次通过静态方法获取时，获取到的时创建过的。一般分为两种实现方式：**饿汉式**和**懒汉式**

**实现单例模式**

饿汉式是说在类加载的时候就创建了实例，懒汉式是说在类加载的时候并没有创建实例，而是当外部获取时创建。饿汉式一般通过 new 或者静态代码块来实现，懒汉式如下：

1. 锁和双重检查法实现

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}  // 私有构造器

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
    
//    这种方式也可以，不过性能比较低，因为每次都会上锁
//    public static synchronized Singleton getInstance() {
//        if (instance == null) {
//            instance = new Singleton();
//        }
//        return instance;
//    }

    public void show() {
        System.out.println("Singleton instance: " + this);
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
        s1.show();
        System.out.println(s1 == s2);  // true
    }
}
```

2. 静态内部类实现

JVM只有在使用某个类时才会加载它，类加载是由JVM控制的，并且他是线程安全的

```java
public class Singleton {
    // 私有构造器，防止外部实例化
    private Singleton() {}

    // 静态内部类，持有单例实例
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // 公共方法获取实例
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    public void show() {
        System.out.println("Singleton instance: " + this);
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
        s1.show();
        System.out.println(s1 == s2);  // true
    }
}
```

**破坏单例模式**

序列化和反序列化，反射 可以破坏单例模式

1. 解决序列化反序列化破坏单例模式的方法：

```java
public class Singleton implements Serializable {
    // 实现这个方法，在反序列化时如果存在这个方法，会被调用，生成反序列化的对象
    public Object readResolve() {
        return instance;
    }
}
```

2. 解决反射破坏单例模式

```java
private Singleton() {
    synchronized {
        if (instance != null) {
            throw new RuntimeException("Singleton already instantiated!");
        }
    }
}
```





#### 1.2 工厂设计模式

工厂模式通过将对象的创建过程封装到工厂类中，隐藏实例化的细节，提供统一的创建接口。核心思想: 将“创建对象”与“使用对象”分离，增强灵活性和可扩展性。

实现方式主要有三种：

1. 简单工厂模式（非正式设计模式）
2. 工厂方法模式（经典设计模式）
3. 抽象工厂模式（复杂产品族模式）



**实现工厂模式**

1. 简单工厂模式

简单工厂模式通过一个工厂类，根据传入的参数创建不同的产品对象。它不属于 GoF 的 23 种经典设计模式，但常作为工厂模式的入门。

核心思想：一个工厂类负责所有产品的创建，客户端通过参数选择所需产品。

结构

- 产品接口: 定义产品的行为。
- 具体产品: 实现产品接口。
- 工厂类: 根据参数创建具体产品。

```java
interface Product {
    void use();
}
class ProductA implements Product {
    public void use() { System.out.println("Using Product A"); }
}
class ProductB implements Product {
    public void use() { System.out.println("Using Product B"); }
}

// 简单工厂, 违反开闭原则
class SimpleFactory {
    public static Product createProduct(String type) {
        if ("A".equals(type)) {
            return new ProductA();
        } else if ("B".equals(type)) {
            return new ProductB();
        }
        return null;
    }
}

public class Main {
    public static void main(String[] args) {
        Product productA = SimpleFactory.createProduct("A");
        Product productB = SimpleFactory.createProduct("B");
        productA.use();  // Using Product A
        productB.use();  // Using Product B
    }
}
```

2. 工厂方法模式（经典设计模式）

定义一个创建对象的接口，让子类（具体工厂）决定实例化哪个类，将对象的创建推迟到子类。（java中的Iterator就是一个对象的接口，在List工厂中创建了这个Iterator实现类）

核心思想：通过工厂接口和具体工厂分离创建职责，支持扩展。

 结构

- 产品接口: 定义产品行为。
- 具体产品: 实现产品接口。
- 工厂接口: 定义创建方法。
- 具体工厂: 实现工厂接口，创建具体产品。

```java
interface Product {
    void use();
}
class ProductA implements Product {
    public void use() { System.out.println("Using Product A"); }
}
class ProductB implements Product {
    public void use() { System.out.println("Using Product B"); }
}
interface Factory {
    Product createProduct();
}
class FactoryA implements Factory {
    public Product createProduct() { return new ProductA(); }
}

class FactoryB implements Factory {
    public Product createProduct() { return new ProductB(); }
}

public class Main {
    public static void main(String[] args) {
        Factory factoryA = new FactoryA();
        Product productA = factoryA.createProduct();
        productA.use();  // Using Product A

        Factory factoryB = new FactoryB();
        Product productB = factoryB.createProduct();
        productB.use();  // Using Product B
    }
}
```

3. 抽象工厂模式

提供一个接口，用于创建一系列相关或依赖的对象（产品族），无需指定具体类。

核心思想：生产一组相关产品，保证产品之间的兼容性。

```java
// 产品接口
interface Button { void render(); }
interface Checkbox { void check(); }

// 具体产品（Windows 产品族）
class WinButton implements Button { public void render() { System.out.println("Windows Button"); } }
class WinCheckbox implements Checkbox { public void check() { System.out.println("Windows Checkbox"); } }

// 具体产品（Mac 产品族）
class MacButton implements Button { public void render() { System.out.println("Mac Button"); } }
class MacCheckbox implements Checkbox { public void check() { System.out.println("Mac Checkbox"); } }

// 抽象工厂
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// 具体工厂
class WinFactory implements GUIFactory {
    public Button createButton() { return new WinButton(); }
    public Checkbox createCheckbox() { return new WinCheckbox(); }
}

class MacFactory implements GUIFactory {
    public Button createButton() { return new MacButton(); }
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}

public class Main {
    public static void main(String[] args) {
        GUIFactory winFactory = new WinFactory();
        Button winButton = winFactory.createButton();
        Checkbox winCheckbox = winFactory.createCheckbox();
        winButton.render();  // Windows Button
        winCheckbox.check(); // Windows Checkbox

        GUIFactory macFactory = new MacFactory();
        Button macButton = macFactory.createButton();
        Checkbox macCheckbox = macFactory.createCheckbox();
        macButton.render();  // Mac Button
        macCheckbox.check(); // Mac Checkbox
    }
}
```

**工厂模式的扩展**

根据配置文件或参数动态选择产品，增强灵活性。

```java
import java.util.Properties;

interface Product {
    void use();
}

class ProductA implements Product {
    public void use() { System.out.println("Using Product A"); }
}

interface Factory {
    Product createProduct();
}

class ConfigurableFactory implements Factory {
    private String productClass;	// 全类名，一般通过配置文件方式获取

    public ConfigurableFactory(String productClass) {
        this.productClass = productClass;
    }

    public Product createProduct() {
        try {
            Class<?> clazz = Class.forName(productClass);
            return (Product) clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create product", e);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // 模拟配置文件
        Properties config = new Properties();
        config.setProperty("product", "ProductA");
        String productClass = config.getProperty("product");

        Factory factory = new ConfigurableFactory(productClass);
        Product product = factory.createProduct();
        product.use();  // Using Product A
    }
}
```





#### 1.3 原型模式

 原型模式通过复制（克隆）一个已有对象来创建新对象，而不是通过构造器重新初始化。核心思想: 使用现有对象作为模板，通过复制其状态生成新对象，减少创建开销。

结构：

1. 原型接口: 定义克隆方法（比如“复制披萨”）。

2. 具体原型: 实现克隆逻辑（比如具体的披萨类型）。

3. 客户端: 使用原型创建新对象（比如顾客点单）。



1. 代码实现（浅拷贝）

```java
// 原型接口
interface Pizza {
    Pizza clone();  // 复制披萨的方法
    void addTopping(String topping);  // 添加配料
}

// 具体披萨类
class MargheritaPizza implements Pizza, Cloneable {  // Cloneable 是 Java 的克隆支持
    private String name;
    private String baseTopping;

    public MargheritaPizza() {
        this.name = "Margherita";
        this.baseTopping = "Tomato, Mozzarella";  // 基础配料
    }

    public void addTopping(String topping) {
        this.baseTopping += ", " + topping;  // 添加新配料
    }

    @Override
    public Pizza clone() {
        try {
            return (Pizza) super.clone();  // 调用 Object 的 clone()，浅拷贝
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    @Override
    public String toString() {
        return name + " Pizza [Toppings: " + baseTopping + "]";
    }
}

public class PizzaShop {
    public static void main(String[] args) {
        // 创建原始披萨模板
        MargheritaPizza original = new MargheritaPizza();
        System.out.println("Original: " + original);

        // 复制一份给顾客，定制新配料
        MargheritaPizza customPizza = (MargheritaPizza) original.clone();
        customPizza.addTopping("Pepperoni");

        System.out.println("Original: " + original);    // 未受影响
        System.out.println("Custom: " + customPizza);   // 新披萨
    }
}
Original: Margherita Pizza [Toppings: Tomato, Mozzarella]
Original: Margherita Pizza [Toppings: Tomato, Mozzarella]
Custom: Margherita Pizza [Toppings: Tomato, Mozzarella, Pepperoni]
```

2. 深拷贝版本（处理引用类型）

```java
import java.util.ArrayList;
import java.util.List;

// 原型接口
interface Pizza {
    Pizza clone();
    void addTopping(String topping);
}

// 具体披萨类
class MargheritaPizza implements Pizza, Cloneable {
    private String name;	// String类型是不可变的
    private List<String> toppings;

    public MargheritaPizza() {
        this.name = "Margherita";
        this.toppings = new ArrayList<>();
        this.toppings.add("Tomato");
        this.toppings.add("Mozzarella");
    }

    public void addTopping(String topping) {
        this.toppings.add(topping);
    }

    @Override
    public Pizza clone() {
        try {
            MargheritaPizza clone = (MargheritaPizza) super.clone();
            clone.toppings = new ArrayList<>(this.toppings);  // 深拷贝配料列表
            return clone;
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    @Override
    public String toString() {
        return name + " Pizza [Toppings: " + toppings + "]";
    }
}

public class PizzaShop {
    public static void main(String[] args) {
        MargheritaPizza original = new MargheritaPizza();
        System.out.println("Original: " + original);

        MargheritaPizza customPizza = (MargheritaPizza) original.clone();
        customPizza.addTopping("Pepperoni");

        System.out.println("Original: " + original);    // 未受影响
        System.out.println("Custom: " + customPizza);   // 新披萨
    }
}
Original: Margherita Pizza [Toppings: [Tomato, Mozzarella]]
Original: Margherita Pizza [Toppings: [Tomato, Mozzarella]]
Custom: Margherita Pizza [Toppings: [Tomato, Mozzarella, Pepperoni]]
```





#### 1.4 建造者模式

建造者模式将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。核心思想: 将对象的构造分解为多个步骤，通过一个独立的建造者逐步完成，最终生成完整对象。

结构：

1. 产品 (Product): 被创建的对象（房子）。

2. 抽象建造者 (Abstract Builder): 定义构建步骤的接口。

3. 具体建造者 (Concrete Builder): 实现步骤，组装具体房子。

4. 指挥者 (Director): 可选，控制构建顺序。

5. 客户端 (Client): 使用建造者创建房子。



1. 完整实现（带指挥者）

```java
// 产品：房子
class House {
    private String door;  // 门
    private String window;  // 窗户
    private String wall;  // 墙

    public void setDoor(String door) { this.door = door; }
    public void setWindow(String window) { this.window = window; }
    public void setWall(String wall) { this.wall = wall; }

    @Override
    public String toString() {
        return "House [Door=" + door + ", Window=" + window + ", Wall=" + wall + "]";
    }
}

// 抽象建造者
interface HouseBuilder {
    void buildDoor();   // 装门
    void buildWindow(); // 装窗户
    void buildWall();   // 砌墙
    House getResult();  // 获取房子
}

// 具体建造者：小房子
class SmallHouseBuilder implements HouseBuilder {
    private House house = new House();

    @Override
    public void buildDoor() { house.setDoor("Wood Door"); }
    @Override
    public void buildWindow() { house.setWindow("Small Window"); }
    @Override
    public void buildWall() { house.setWall("Brick Wall"); }
    @Override
    public House getResult() { return house; }
}

// 具体建造者：大房子
class BigHouseBuilder implements HouseBuilder {
    private House house = new House();

    @Override
    public void buildDoor() { house.setDoor("Metal Door"); }
    @Override
    public void buildWindow() { house.setWindow("Big Window"); }
    @Override
    public void buildWall() { house.setWall("Stone Wall"); }
    @Override
    public House getResult() { return house; }
}

// 指挥者
class HouseDirector {
    private HouseBuilder builder;

    public HouseDirector(HouseBuilder builder) {
        this.builder = builder;
    }

    public House construct() {
        builder.buildDoor();
        builder.buildWindow();
        builder.buildWall();
        return builder.getResult();
    }
}

public class Main {
    public static void main(String[] args) {
        // 建小房子
        HouseBuilder smallBuilder = new SmallHouseBuilder();
        HouseDirector director = new HouseDirector(smallBuilder);
        House smallHouse = director.construct();
        System.out.println("Small House: " + smallHouse);

        // 建大房子
        HouseBuilder bigBuilder = new BigHouseBuilder();
        director = new HouseDirector(bigBuilder);
        House bigHouse = director.construct();
        System.out.println("Big House: " + bigHouse);
    }
}
```

2. 简化版

```java
class House {
    private String door;
    private String window;
    private String wall;

    // 私有构造器，只能通过建造者创建
    private House(HouseBuilder builder) {
        this.door = builder.door;
        this.window = builder.window;
        this.wall = builder.wall;
    }

    @Override
    public String toString() {
        return "House [Door=" + door + ", Window=" + window + ", Wall=" + wall + "]";
    }

    // 静态内部建造者
    public static class HouseBuilder {
        private String door;
        private String window;
        private String wall;

        public HouseBuilder setDoor(String door) {
            this.door = door;
            return this;
        }

        public HouseBuilder setWindow(String window) {
            this.window = window;
            return this;
        }

        public HouseBuilder setWall(String wall) {
            this.wall = wall;
            return this;
        }

        public House build() {
            return new House(this);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        House house = new House.HouseBuilder()
                .setDoor("Wood Door")
                .setWindow("Small Window")
                .setWall("Brick Wall")
                .build();
        System.out.println(house);
    }
}
```



### 2. 结构型模式

结构型模式（Structural Patterns）是设计模式的一种分类，关注如何**将类和对象组合成更大的结构**，以实现功能的扩展、组织和优化。它们通过定义类与对象之间的关系，来提高系统的灵活性、可维护性和复用性。

#### 2.1 代理模式（Proxy Pattern）

通过代理对象控制对真实对象的访问，增加额外的功能或延迟加载。核心思想：用代理对象代替真实对象，控制访问或增强行为。

角色：

- 抽象主题（Subject）
- 真实主题（RealSubject）
- 代理（Proxy）

```java
interface Image {
    void display();
}

class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        System.out.println("Loading " + filename + " from disk...");
    }

    public void display() {
        System.out.println("Displaying " + filename);
    }
}

class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

public class ProxyDemo {
    public static void main(String[] args) {
        Image image = new ProxyImage("photo.jpg");
        image.display();
        image.display();
    }
}
```

角色解释

1. 抽象主题（Subject） - Image
   - 定义：一个接口，定义了真实对象和代理对象的公共方法。
   - 作用：确保客户端可以通过统一的方式调用 display()，无需关心是代理还是真实对象。
   - 代码中：interface Image 定义了 display() 方法。
2. 真实主题（RealSubject） - RealImage
   - 定义：实现抽象主题的具体类，执行实际操作。
   - 作用：负责核心功能（加载并显示图片），但创建成本可能较高。
   - 代码中：RealImage 在构造时模拟从磁盘加载图片，display() 输出显示信息。
3. 代理（Proxy） - ProxyImage
   - 定义：实现抽象主题，持有真实对象的引用。
   - 作用：控制对 RealImage 的访问，这里实现了延迟加载（只有第一次调用时才创建真实对象）。
   - 代码中：ProxyImage 检查 realImage 是否为空，若为空则创建并调用其 display()。



#### 2.2 适配器模式（Adapter Pattern）

将一个类的接口转换成客户端期望的另一个接口，使不兼容的类能够一起工作。核心思想：通过适配器转换接口，解决兼容性问题。
角色：

- 目标接口（Target）
- 被适配者（Adaptee）
- 适配器（Adapter）

```java
// 目标接口
interface Printer {
    void print(String message);
}

// 被适配者
class OldPrinter {
    public void printOld(String text) {
        System.out.println("Old Printer: " + text);
    }
}

// 适配器
class PrinterAdapter implements Printer {
    private OldPrinter oldPrinter;

    public PrinterAdapter(OldPrinter oldPrinter) {
        this.oldPrinter = oldPrinter;
    }

    @Override
    public void print(String message) {
        oldPrinter.printOld(message); // 转换调用
    }
}

// 测试
public class AdapterDemo {
    public static void main(String[] args) {
        OldPrinter oldPrinter = new OldPrinter();
        Printer printer = new PrinterAdapter(oldPrinter);
        printer.print("Hello, Adapter!");
    }
}
```

角色解释

1. 目标接口（Target） - Printer
   - 定义：客户端期望使用的接口。
   - 作用：定义新系统需要的打印方法，适配器必须实现它。
   - 代码中：interface Printer 定义了 print() 方法。
2. 被适配者（Adaptee） - OldPrinter
   - 定义：已有但接口不兼容的类。
   - 作用：提供实际功能，但方法名（printOld）与目标接口不匹配。
   - 代码中：OldPrinter 的 printOld() 实现老式打印逻辑。
3. 适配器（Adapter） - PrinterAdapter
   - 定义：实现目标接口，持有被适配者引用。
   - 作用：将 print() 调用转换为 printOld()，桥接新旧接口。
   - 代码中：PrinterAdapter 接收 OldPrinter 实例，适配其方法。



#### 2.3 装饰者模式（Decorator Pattern）

动态地为对象添加额外的职责，比继承更灵活。核心思想：通过装饰器包装对象，增强功能。
角色：

- 抽象组件（Component）
- 具体组件（ConcreteComponent）
- 抽象装饰者（Decorator）
- 具体装饰者（ConcreteDecorator）

```java
// 抽象组件
interface Window {
    void render();
    String getDescription();
}

// 具体组件
class SimpleWindow implements Window {
    @Override
    public void render() {
        System.out.println("Rendering a simple window");
    }

    @Override
    public String getDescription() {
        return "Simple Window";
    }
}

// 抽象装饰者
abstract class WindowDecorator implements Window {
    protected Window window;

    public WindowDecorator(Window window) {
        this.window = window;
    }

    @Override
    public void render() {
        window.render();
    }

    @Override
    public String getDescription() {
        return window.getDescription();
    }
}

// 具体装饰者 - 添加滚动条
class ScrollBarDecorator extends WindowDecorator {
    public ScrollBarDecorator(Window window) {
        super(window);
    }

    @Override
    public void render() {
        window.render();
        System.out.println("Adding scroll bars");
    }

    @Override
    public String getDescription() {
        return window.getDescription() + " with Scroll Bars";
    }
}

// 具体装饰者 - 添加边框
class BorderDecorator extends WindowDecorator {
    public BorderDecorator(Window window) {
        super(window);
    }

    @Override
    public void render() {
        window.render();
        System.out.println("Adding a border");
    }

    @Override
    public String getDescription() {
        return window.getDescription() + " with Border";
    }
}

// 测试类
public class DecoratorDemo {
    public static void main(String[] args) {
        // 创建基础窗口
        Window window = new SimpleWindow();

        // 添加滚动条装饰
        window = new ScrollBarDecorator(window);

        // 再添加边框装饰
        window = new BorderDecorator(window);

        // 渲染并输出描述
        window.render();
        System.out.println("Description: " + window.getDescription());
    }
}
```

角色解释

1. 抽象组件（Component） - Window
   - 定义：一个接口，定义了窗口组件的基本行为。
   - 作用：为具体组件和装饰者提供统一的接口，确保它们可以被一致地调用。
   - 代码中：interface Window 定义了 render()（绘制窗口）和 getDescription()（描述窗口）两个方法。
2. 具体组件（ConcreteComponent） - SimpleWindow
   - 定义：实现抽象组件的具体类，表示一个基础窗口。
   - 作用：提供最基本的功能，作为装饰的起点。
   - 代码中：SimpleWindow 实现了一个简单的窗口，渲染时输出基本信息，描述为 "Simple Window"。
3. 抽象装饰者（Decorator） - WindowDecorator
   - 定义：实现抽象组件的抽象类，持有被装饰对象的引用。
   - 作用：为具体装饰者提供公共逻辑，默认调用被装饰对象的方法，确保装饰者与组件接口一致。
   - 代码中：WindowDecorator 持有 Window 引用，并默认转发 render() 和 getDescription() 调用。
4. 具体装饰者（ConcreteDecorator） - ScrollBarDecorator 和 BorderDecorator
   - 定义：继承抽象装饰者，添加具体功能的类。
   - 作用：在基础功能上动态增强行为，比如添加滚动条或边框。
   - 代码中：
     - ScrollBarDecorator：在渲染时添加滚动条逻辑，描述中增加 "with Scroll Bars"。
     - ‚BorderDecorator：在渲染时添加边框逻辑，描述中增加 "with Border"。



#### 2.4 桥接模式（Bridge Pattern）

将抽象部分与实现部分分离，使它们可以独立变化。核心思想：通过组合而非继承解耦抽象和实现。
角色：

- 抽象类（Abstraction）
- 扩展抽象类（RefinedAbstraction）
- 实现接口（Implementor）
- 具体实现（ConcreteImplementor）

```java
interface Color {
    String fill();
}

class Red implements Color {
    public String fill() {
        return "Red";
    }
}

abstract class Shape {
    protected Color color;

    public Shape(Color color) {
        this.color = color;
    }

    abstract String draw();
}

class Circle extends Shape {
    public Circle(Color color) {
        super(color);
    }

    public String draw() {
        return "Drawing Circle with " + color.fill() + " color";
    }
}

public class BridgeDemo {
    public static void main(String[] args) {
        Shape circle = new Circle(new Red());
        System.out.println(circle.draw());
    }
}
```

角色解释

1. 实现接口（Implementor） - Color
   - 定义：定义实现部分的接口。
   - 作用：提供具体实现的抽象方法。
   - 代码中：interface Color 定义了 fill()。
2. 具体实现（ConcreteImplementor） - Red
   - 定义：实现接口的具体类。
   - 作用：提供实现细节（如返回 "Red"）。
   - 代码中：Red 实现 fill() 返回颜色。
3. 抽象类（Abstraction） - Shape
   - 定义：持有实现接口引用，定义抽象部分。
   - 作用：通过组合调用实现部分。
   - 代码中：Shape 抽象类持有 Color。
4. 扩展抽象类（RefinedAbstraction） - Circle
   - 定义：继承抽象类，提供具体逻辑。
   - 作用：实现抽象方法，结合实现部分。
   - 代码中：Circle 定义圆形的绘制方式。





#### 2.5 外观模式（Facade Pattern）

为复杂子系统提供一个简单的统一接口。核心思想：隐藏子系统复杂性，提供简洁入口。
角色：

- 外观（Facade）
- 子系统（Subsystem）

```java
class CPU {
    public void start() {
        System.out.println("CPU is starting...");
    }
}

class Memory {
    public void load() {
        System.out.println("Memory is loading...");
    }
}

class HardDrive {
    public void read() {
        System.out.println("Hard Drive is reading...");
    }
}

class ComputerFacade {
    private CPU cpu = new CPU();
    private Memory memory = new Memory();
    private HardDrive hardDrive = new HardDrive();

    public void start() {
        cpu.start();
        memory.load();
        hardDrive.read();
    }
}

public class FacadeDemo {
    public static void main(String[] args) {
        ComputerFacade computer = new ComputerFacade();
        computer.start();
    }
}
```

角色解释

1. 子系统（Subsystem） - CPU, Memory, HardDrive
   - 定义：一组独立类，完成具体功能。
   - 作用：实现系统的底层操作。
   - 代码中：分别模拟 CPU、内存和硬盘的操作。
2. 外观（Facade） - ComputerFacade
   - 定义：封装子系统的类，提供简单接口。
   - 作用：隐藏子系统复杂性，统一调用。
   - 代码中：ComputerFacade 整合三个子系统的启动过程。



#### 2.6 组合模式（Composite Pattern）

将对象组合成树形结构，以统一处理单个对象和组合对象。核心思想：部分-整体层次结构一致性。
角色：

- 组件（Component）
- 叶子（Leaf）
- 组合（Composite）

```java
interface Graphic {
    void draw();
}

class Dot implements Graphic {
    public void draw() {
        System.out.println("Drawing a Dot");
    }
}

class CompoundGraphic implements Graphic {
    private java.util.List<Graphic> children = new java.util.ArrayList<>();

    public void add(Graphic graphic) {
        children.add(graphic);
    }

    public void draw() {
        for (Graphic graphic : children) {
            graphic.draw();
        }
    }
}

public class CompositeDemo {
    public static void main(String[] args) {
        CompoundGraphic group = new CompoundGraphic();
        group.add(new Dot());
        group.add(new Dot());
        group.draw();
    }
}
```

角色解释

1. 组件（Component） - Graphic
   - 定义：定义叶子和组合的公共接口。
   - 作用：统一操作接口。
   - 代码中：interface Graphic 定义 draw()。
2. 叶子（Leaf） - Dot
   - 定义：实现组件接口，表示单个对象。
   - 作用：执行具体操作，无子节点。
   - 代码中：Dot 绘制单个点。
3. 组合（Composite） - CompoundGraphic
   - 定义：实现组件接口，管理子节点。
   - 作用：递归调用子节点的相同方法。
   - 代码中：CompoundGraphic 存储并绘制多个 Graphic。



#### 2.7 享元模式（Flyweight Pattern）

定义：通过共享对象来减少内存使用，适用于大量相似对象。
核心思想：分离内在状态（共享）和外在状态（不共享）。
角色：

- 享元接口（Flyweight）
- 具体享元（ConcreteFlyweight）
- 享元工厂（FlyweightFactory）

```java
interface Tree {
    void display(int x, int y);
}

class TreeType {
    private String name;

    public TreeType(String name) {
        this.name = name;
    }

    public void display(int x, int y) {
        System.out.println(name + " tree at (" + x + ", " + y + ")");
    }
}

class TreeFactory {
    private static java.util.Map<String, TreeType> treeTypes = new java.util.HashMap<>();

    public static TreeType getTreeType(String name) {
        return treeTypes.computeIfAbsent(name, TreeType::new);
    }
}

public class FlyweightDemo {
    public static void main(String[] args) {
        TreeType oak = TreeFactory.getTreeType("Oak");
        oak.display(1, 2);
        oak.display(3, 4);
    }
}
```

角色解释

1. 享元接口（Flyweight） - Tree
   - 定义：定义共享对象的接口。
   - 作用：声明共享行为，接受外在状态。
   - 代码中：interface Tree 定义 display(x, y)。
2. 具体享元（ConcreteFlyweight） - TreeType
   - 定义：实现享元接口，存储内在状态。
   - 作用：实现共享逻辑，内在状态（如 name）不可变。
   - 代码中：TreeType 存储树类型，显示时用外在状态 (x, y)。
3. 享元工厂（FlyweightFactory） - TreeFactory
   - 定义：管理享元对象的类。
   - 作用：缓存并返回共享实例。
   - 代码中：TreeFactory 使用 Map 缓存 TreeType。



### 3. 行为型模式

行为型模式（Behavioral Patterns）是设计模式的第三大分类（继创建型模式和结构型模式之后），专注于**对象之间的通信和职责分配**。它们描述了对象如何协作、如何分配任务以及如何通过交互完成复杂的行为。行为型模式的目标是提高系统的灵活性、可维护性和职责清晰度，解决“对象如何相互作用”的问题。

#### 3.1 责任链模式

将请求沿一系列处理者传递，每个处理者决定处理请求或传递给下一个处理者。核心思想：解耦请求的发送者和接收者，支持动态调整处理链。

角色

- Handler（抽象处理者）：定义处理请求的接口，通常包含指向下一个处理者的引用。
- ConcreteHandler（具体处理者）：实现处理逻辑，或将请求传递给下一个处理者。
- Client（客户端）：发起请求。

```java
abstract class Handler {
    protected Handler next;
    public void setNext(Handler next) { this.next = next; }
    abstract void handleRequest(String request);
}

class ConcreteHandlerA extends Handler {
    public void handleRequest(String request) {
        if (request.equals("A")) {
            System.out.println("Handler A processed: " + request);
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

class ConcreteHandlerB extends Handler {
    public void handleRequest(String request) {
        if (request.equals("B")) {
            System.out.println("Handler B processed: " + request);
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

public class ChainDemo {
    public static void main(String[] args) {
        Handler handlerA = new ConcreteHandlerA();
        Handler handlerB = new ConcreteHandlerB();
        handlerA.setNext(handlerB);

        handlerA.handleRequest("A");
        handlerA.handleRequest("B");
        handlerA.handleRequest("C");
    }
}
```

运行逻辑

- 创建处理链：handlerA -> handlerB。

- 请求 "A"：handlerA 处理，停止。

- 请求 "B"：handlerA 传递给 handlerB，处理。

- 请求 "C"：无人处理，链结束。

- 输出：

  ```text
  Handler A processed: A
  Handler B processed: B
  ```



#### 3.2 命令模式

将请求封装为对象，支持撤销、重做等操作。核心思想：解耦命令的发起者和执行者，将操作抽象化。

角色

- Command（命令）：定义命令接口。
- ConcreteCommand（具体命令）：实现命令，绑定接收者。
- Receiver（接收者）：执行具体操作。
- Invoker（调用者）：触发命令执行。

```java
interface Command {
    void execute();
}

class Receiver {
    public void action() {
        System.out.println("Receiver performs action");
    }
}

class ConcreteCommand implements Command {
    private Receiver receiver;
    public ConcreteCommand(Receiver receiver) { this.receiver = receiver; }
    public void execute() { receiver.action(); }
}

class Invoker {
    private Command command;
    public void setCommand(Command command) { this.command = command; }
    public void executeCommand() { command.execute(); }
}

public class CommandDemo {
    public static void main(String[] args) {
        Receiver receiver = new Receiver();
        Command command = new ConcreteCommand(receiver);
        Invoker invoker = new Invoker();
        invoker.setCommand(command);
        invoker.executeCommand();
    }
}
```

运行逻辑

- Invoker 持有 Command，调用 execute()。

- ConcreteCommand 委托 Receiver 执行 action()。

- 输出：

  ```text
  Receiver performs action
  ```



#### 3.3 解释器模式

为语言定义文法，通过解释器解析表达式。核心思想：将语法规则封装为对象，解释特定语言。

角色

- Expression（抽象表达式）：定义解释方法。
- TerminalExpression（终结符表达式）：实现基本表达式。
- NonTerminalExpression（非终结符表达式）：组合表达式。
- Context（上下文）：提供解释所需的信息（可选）。

```java
interface Expression {
    int interpret();
}

class Number implements Expression {
    private int value;
    public Number(int value) { this.value = value; }
    public int interpret() { return value; }
}

class Plus implements Expression {
    private Expression left, right;
    public Plus(Expression left, Expression right) { this.left = left; this.right = right; }
    public int interpret() { return left.interpret() + right.interpret(); }
}

public class InterpreterDemo {
    public static void main(String[] args) {
        Expression expression = new Plus(new Number(5), new Number(3));
        System.out.println("Result: " + expression.interpret());
    }
}
```

运行逻辑

- 构造表达式：5 + 3。

- Plus 递归调用 Number 的 interpret()，计算结果。

- 输出：

  ```text
  Result: 8
  ```



#### 3.4 迭代器模式

顺序访问聚合对象元素，不暴露内部结构。核心思想：提供统一的遍历方式。

角色

- Iterator（迭代器）：定义遍历接口。
- ConcreteIterator（具体迭代器）：实现遍历逻辑。
- Aggregate（聚合）：定义创建迭代器的方法。
- ConcreteAggregate（具体聚合）：存储数据并返回迭代器。

```java
interface Iterator {
    boolean hasNext();
    Object next();
}

interface Aggregate {
    Iterator createIterator();
}

class ArrayAggregate implements Aggregate {
    private String[] array = {"A", "B", "C"};
    public Iterator createIterator() { return new ArrayIterator(array); }
}

class ArrayIterator implements Iterator {
    private String[] array;
    private int index = 0;
    public ArrayIterator(String[] array) { this.array = array; }
    public boolean hasNext() { return index < array.length; }
    public Object next() { return array[index++]; }
}

public class IteratorDemo {
    public static void main(String[] args) {
        Aggregate aggregate = new ArrayAggregate();
        Iterator iterator = aggregate.createIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

运行逻辑

- ArrayAggregate 创建 ArrayIterator。

- 迭代器顺序访问数组元素。

- 输出：

  ```text
  A
  B
  C
  ```

#### 3.5 中介者模式

通过中介者协调多个对象间的交互。核心思想：减少对象间的直接依赖。

角色

- Mediator（中介者）：定义通信接口。
- ConcreteMediator（具体中介者）：实现协调逻辑。
- Colleague（同事）：通过中介者通信的对象。

```java
interface Mediator {
    void send(String message, Colleague colleague);
}

abstract class Colleague {
    protected Mediator mediator;
    public Colleague(Mediator mediator) { this.mediator = mediator; }
    abstract void notify(String message);
}

class ConcreteColleague1 extends Colleague {
    public ConcreteColleague1(Mediator mediator) { super(mediator); }
    public void send(String message) { mediator.send(message, this); }
    public void notify(String message) { System.out.println("Colleague1 received: " + message); }
}

class ConcreteColleague2 extends Colleague {
    public ConcreteColleague2(Mediator mediator) { super(mediator); }
    public void send(String message) { mediator.send(message, this); }
    public void notify(String message) { System.out.println("Colleague2 received: " + message); }
}

class ConcreteMediator implements Mediator {
    private ConcreteColleague1 c1;
    private ConcreteColleague2 c2;
    public void setColleagues(ConcreteColleague1 c1, ConcreteColleague2 c2) { this.c1 = c1; this.c2 = c2; }
    public void send(String message, Colleague colleague) {
        if (colleague == c1) c2.notify(message);
        else c1.notify(message);
    }
}

public class MediatorDemo {
    public static void main(String[] args) {
        ConcreteMediator mediator = new ConcreteMediator();
        ConcreteColleague1 c1 = new ConcreteColleague1(mediator);
        ConcreteColleague2 c2 = new ConcreteColleague2(mediator);
        mediator.setColleagues(c1, c2);
        c1.send("Hello from C1");
        c2.send("Hi from C2");
    }
}
```

运行逻辑

- c1 发送消息，Mediator 转发给 c2。

- c2 发送消息，Mediator 转发给 c1。

- 输出：

  ```text
  Colleague2 received: Hello from C1
  Colleague1 received: Hi from C2
  ```



#### 3.6 备忘录模式

捕获并恢复对象的状态，不破坏封装。核心思想：保存和恢复快照。

角色

- Memento（备忘录）：存储状态。
- Originator（发起人）：创建和恢复状态。
- Caretaker（管理者）：保存备忘录。

```java
class Memento {
    private String state;
    public Memento(String state) { this.state = state; }
    public String getState() { return state; }
}

class Originator {
    private String state;
    public void setState(String state) { this.state = state; System.out.println("State set to: " + state); }
    public Memento save() { return new Memento(state); }
    public void restore(Memento memento) { state = memento.getState(); System.out.println("State restored to: " + state); }
}

class Caretaker {
    private Memento memento;
    public void setMemento(Memento m) { memento = m; }
    public Memento getMemento() { return memento; }
}

public class MementoDemo {
    public static void main(String[] args) {
        Originator originator = new Originator();
        Caretaker caretaker = new Caretaker();
        originator.setState("State1");
        caretaker.setMemento(originator.save());
        originator.setState("State2");
        originator.restore(caretaker.getMemento());
    }
}
```

运行逻辑

- 设置状态 "State1"，保存到备忘录。

- 修改为 "State2"，然后恢复到 "State1"。

- 输出：

  ```text
  State set to: State1
  State set to: State2
  State restored to: State1
  ```



#### 3.7 观察者模式

一对多依赖，当状态变化时通知所有观察者。核心思想：实现发布-订阅机制。

角色

- Subject（主题）：管理观察者，通知状态变化。
- ConcreteSubject（具体主题）：维护状态。
- Observer（观察者）：定义更新接口。
- ConcreteObserver（具体观察者）：处理通知。

```java
interface Observer {
    void update(String message);
}

interface Subject {
    void attach(Observer observer);
    void notifyObservers();
}

class ConcreteSubject implements Subject {
    private java.util.List<Observer> observers = new java.util.ArrayList<>();
    private String state;
    public void setState(String state) { this.state = state; notifyObservers(); }
    public void attach(Observer observer) { observers.add(observer); }
    public void notifyObservers() { for (Observer o : observers) o.update(state); }
}

class ConcreteObserver implements Observer {
    private String name;
    public ConcreteObserver(String name) { this.name = name; }
    public void update(String message) { System.out.println(name + " received: " + message); }
}

public class ObserverDemo {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();
        subject.attach(new ConcreteObserver("Observer1"));
        subject.attach(new ConcreteObserver("Observer2"));
        subject.setState("New State");
    }
}
```

运行逻辑

- 添加两个观察者，改变状态，所有观察者收到通知。

- 输出：

  ```text
  Observer1 received: New State
  Observer2 received: New State
  ```



#### 3.8 状态模式

对象状态变化时改变行为。核心思想：封装状态相关行为。

角色

- State（状态）：定义状态接口。
- ConcreteState（具体状态）：实现状态行为。
- Context（上下文）：持有当前状态。

```java
interface State {
    void handle(Context context);
}

class ConcreteStateA implements State {
    public void handle(Context context) {
        System.out.println("State A");
        context.setState(new ConcreteStateB());
    }
}

class ConcreteStateB implements State {
    public void handle(Context context) {
        System.out.println("State B");
        context.setState(new ConcreteStateA());
    }
}

class Context {
    private State state;
    public Context() { state = new ConcreteStateA(); }
    public void setState(State state) { this.state = state; }
    public void request() { state.handle(this); }
}

public class StateDemo {
    public static void main(String[] args) {
        Context context = new Context();
        context.request();
        context.request();
    }
}
```

运行逻辑

- 初始状态为 A，调用后切换到 B，再调用切换回 A。

- 输出：

  ```text
  State A
  State B
  ```



#### 3.9 策略模式

定义一系列算法，封装并使它们可互换。核心思想：动态切换行为。

角色

- Strategy（策略）：定义算法接口。
- ConcreteStrategy（具体策略）：实现具体算法。
- Context（上下文）：使用策略。

```java
interface Strategy {
    void execute();
}

class ConcreteStrategyA implements Strategy {
    public void execute() { System.out.println("Strategy A"); }
}

class ConcreteStrategyB implements Strategy {
    public void execute() { System.out.println("Strategy B"); }
}

class Context {
    private Strategy strategy;
    public void setStrategy(Strategy strategy) { this.strategy = strategy; }
    public void executeStrategy() { strategy.execute(); }
}

public class StrategyDemo {
    public static void main(String[] args) {
        Context context = new Context();
        context.setStrategy(new ConcreteStrategyA());
        context.executeStrategy();
        context.setStrategy(new ConcreteStrategyB());
        context.executeStrategy();
    }
}
```

运行逻辑

- 设置策略 A 执行，然后切换到策略 B。

- 输出：

  ```text
  Strategy A
  Strategy B
  ```



#### 3.10 模板方法模式

定义算法骨架，延迟某些步骤到子类实现。核心思想：复用通用流程。

角色

- AbstractClass（抽象类）：定义模板方法和抽象步骤。
- ConcreteClass（具体类）：实现具体步骤。

```java
abstract class AbstractClass {
    public void templateMethod() {
        step1();
        step2();
        System.out.println("Template finished");
    }
    abstract void step1();
    abstract void step2();
}

class ConcreteClass extends AbstractClass {
    void step1() { System.out.println("Step 1"); }
    void step2() { System.out.println("Step 2"); }
}

public class TemplateDemo {
    public static void main(String[] args) {
        AbstractClass obj = new ConcreteClass();
        obj.templateMethod();
    }
}
```

运行逻辑

- 调用模板方法，执行子类实现的步骤。

- 输出：

  ```text
  Step 1
  Step 2
  Template finished
  ```



#### 3.11 访问者模式

将操作与对象结构分离，允许添加新操作。核心思想：扩展功能而不改动结构。

角色

- Visitor（访问者）：定义访问元素的操作。
- ConcreteVisitor（具体访问者）：实现具体访问逻辑。
- Element（元素）：定义接受访问者的方法。
- ConcreteElement（具体元素）：实现接受逻辑。

```java
interface Visitor {
    void visit(ElementA element);
    void visit(ElementB element);
}

interface Element {
    void accept(Visitor visitor);
}

class ElementA implements Element {
    public void accept(Visitor visitor) { visitor.visit(this); }
    public void operationA() { System.out.println("Operation A"); }
}

class ElementB implements Element {
    public void accept(Visitor visitor) { visitor.visit(this); }
    public void operationB() { System.out.println("Operation B"); }
}

class ConcreteVisitor implements Visitor {
    public void visit(ElementA element) { element.operationA(); System.out.println("Visited A"); }
    public void visit(ElementB element) { element.operationB(); System.out.println("Visited B"); }
}

public class VisitorDemo {
    public static void main(String[] args) {
        Element[] elements = {new ElementA(), new ElementB()};
        Visitor visitor = new ConcreteVisitor();
        for (Element e : elements) {
            e.accept(visitor);
        }
    }
}
```

运行逻辑

- 元素接受访问者，访问者执行对应操作。

- 输出：

  ```text
  Operation A
  Visited A
  Operation B
  Visited B
  ```







