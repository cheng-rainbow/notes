**设计原则**是高层指导，**设计模式**是具体实现。**设计模式**是在**设计原则**指导下发展出来的。换句话说，设计模式是原则的具体化体现。

## 一、UML

### 1. 类图

UML类图是一个矩形框，分为三部分，上中下分别表示：`类名`，`属性（成员变量）`，`操作（方法）`

```uml
+---------------------------+
|    Person      		    |
+---------------------------+
| - name: String  			|
| - age: int      			|
+---------------------------+
| + getName(): String 		|
| + setAge(int age): void  |
+---------------------------+
```

属性和操作名前面的符号表示这个属性或操作的可见性

`+` 表示 public，`-` 表示 private，`#` 表示 protected, 还有默认



属性格式: `可见性` `名称:` `类型` `[默认值]`，如 - name: String。

方法格式: `可见性` `名称(参数列表):` `[返回类型]`，如 + setName(int name): String。



### 2. 类与类之间的关系

#### 2.1 **`依赖`关系**

表示一个类临时使用另一个类，通常通过方法参数、局部变量或静态调用。是最弱的关系，生命周期无关。

表示方式：**虚线箭头**指向被依赖的类。

```java
class Payment {
    public void pay() {
        System.out.println("Paid.");
    }
}

class Order {
    public void processPayment(Payment payment) {
        payment.pay();  // 临时依赖 Payment
    }
}
Order --> Payment
```

#### 2.2 **`关联`关系**

表示两个类之间存在某种联系，通常是“使用”或“知道”的关系，是是最基础、最松散的关系。

表示方式：用**实线**连接两个类，带**箭头**的是双向关联，不带箭头的是单向关联（指向被关联的类）. 

```java
class Person {
    private List<Car> cars;  
    public void addCar(Car car) {
        cars.add(car);
    }
}

class Car {
}
Person —> Car
```

#### 2.3 **`聚合`关系**

一种特殊的关联，表示 **“整体-部分”** 关系，但**部分可以独立于整体存在**，是一种“has-a”关系，整体不控制部分的生命周期。

表示方式：用**实线**连接两个类，但是用**空心菱形**指向整体

```java
class University {
    private List<Department> departments;

    public void addDepartment(Department dept) {
        departments.add(dept);
    }
}

class Department {
    // 无需持有 University 的引用
}
Department -◇ University
```

#### 2.4 **`组合`关系**

更强的 **“整体-部分”** 关系，**部分随整体的销毁而销毁**。也是一种“has-a”关系，但整体控制部分的生命周期。

表示方式：用**实线**连接两个类，但是用**实心菱形**指向整体

```java
class House {
    private List<Room> rooms;

    public House() {
        rooms = new ArrayList<>();  // Room 在 House 中创建
        rooms.add(new Room());
    }
}

class Room {
    // Room 的生命周期依赖 House
}
Room -◆ House
```

#### 2.5 **`继承`关系**

表示类之间的“is-a”关系，子类继承父类的属性和方法。是面向对象编程的基础特性之一

表示方式：用**实线**连接两个类，**空心三角**指向父类

```java
abstract class Animal {
    protected String species;
    public void move() {
        System.out.println("Moving...");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Woof!");
    }
}
Dog -|> Animal
```

#### 2.6 **`实现`关系**

表示一个类实现某个接口，承诺提供接口定义的行为。是一种“can-do”关系。

表示方式：**虚线**加**空心三角**指向接口。

```java
interface Printable {
    void print();
}

class Printer implements Printable {
    public void print() {
        System.out.println("Printing...");
    }
}
Printer --|> Printable
```



## 一、软件设计原则

### 1. 单一职责原则（SRP）	

**定义**: 一个类应该只有一个职责，或者说只有一个引起它变化的原因。

**核心思想**: 将功能分离，避免一个类承担过多职责。

反面示例：

```java
class User {
    private String name;
    public void saveToDatabase() { /* 数据库操作 */ }
    public void sendEmail() { /* 发送邮件 */ }
}
```

正面示例：

```java
class User {
    private String name;
}

class UserRepository {
    public void saveToDatabase(User user) { /* 数据库操作 */ }
}

class EmailService {
    public void sendEmail(User user) { /* 发送邮件 */ }
}
```



### 2. 开闭原则（OCP）

**定义**：软件实体（类、模块、函数等）应对扩展开放，对修改关闭。

**核心思想**: 通过抽象和多态新增功能，而不是修改现有代码。

反面示例：（胖虎换皮，不同皮肤）

```java
// 每次扩展都需要对原有类PangHu进行修改，修改BlueSkin为OriginSkin
public class PangHu {
    BlueSkin skin;

    public void setSkin(BlueSkin skin) {
    }

    public void display() {
        skin.display();
    }
}

public class PangHu {
    Oringin skin;

    public void setSkin(Oringin skin) {
    }

    public void display() {
        skin.display();
    }
}
```

正面示例：（胖虎换皮，不同皮肤）

```java
// 对修改关闭，不需要修改PangHu类
public abstract class AbstractSkin {

    public abstract void display();
}
public class BlueSkin extends AbstractSkin {
    @Override
    public void display() {
        System.out.println("Blue skin");
    }
}
public class OriginSkin extends AbstractSkin {
    @Override
    public void display() {
        System.out.println("Origin skin");
    }
}
public class PangHu {
    AbstractSkin skin;

    public void setSkin(AbstractSkin skin) {
        this.skin = skin;
    }

    public void display() {
        skin.display();
    }
}

public class Main {
    public static void main(String[] args) {
        PangHu pangHu = new PangHu();
        pangHu.setSkin(new OriginSkin());
        pangHu.display();

        pangHu.setSkin(new BlueSkin());
        pangHu.display();
    }
}
// 输出
Origin skin
Blue skin
```



### 3. 依赖倒置原则（DIP）

**定义**：高层模块不依赖低层模块，二者都依赖抽象；抽象不应该依赖细节，细节依赖抽象。（依赖的高层模块，被依赖的是底层模块，也就是类中的变量是底层模块）

**核心思想**: 通过接口或抽象类解耦，使用依赖注入。

反面示例：

```java
// Computer 直接使用 IntelCpu 和 ShanDiHardDisk。
// 高层模块（Computer）与低层模块（IntelCpu 和 ShanDiHardDisk）紧耦合。
public class IntelCpu {
    private String name;

    public IntelCpu(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
public class ShanDiHardDisk {
    private String name;

    public ShanDiHardDisk(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

// 高层模块直接依赖具体实现，违反 DIP
public class Computer {
    // 直接使用具体类，而不是抽象
    private IntelCpu cpu;
    private ShanDiHardDisk hardDisk;

    public Computer() {
        this.cpu = new IntelCpu("intel");
        this.hardDisk = new ShanDiHardDisk("shanDi");
    }

    public void show() {
        System.out.println("cpu: " + cpu.getName());
        System.out.println("hardDisk: " + hardDisk.getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.show();
    }
}
```

正面示例：

```java
// 高层模块Computer 类依赖抽象（Cpu 和 HardDisk），而不是具体实现（IntelCpu 和 ShanDiHardDisk）。
// 低层模块IntelCpu 和 ShanDiHardDisk 实现接口，通过构造器注入到 Computer。
// 如果需要更换 CPU 或硬盘（比如用 AMDCpu 替换 IntelCpu），只需创建新实现类，无需修改 Computer，符合 DIP。
public interface Cpu {
}
public interface HardDisk {
}
public class ShanDiHardDisk implements HardDisk {
    private String name;

    public ShanDiHardDisk(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
public class IntelCpu implements Cpu{
    private String name;

    public IntelCpu(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
// 高层模块，如果直接使用底层模块，会对修改开放，需要修改Computer类
public class Computer {
	// 底层模块的抽象
    private Cpu cpu;

    private HardDisk hardDisk;

    public Computer(Cpu cpu, HardDisk hardDisk) {
        this.cpu = cpu;
        this.hardDisk = hardDisk;
    }
    public void show() {
        System.out.println("cpu: " + cpu);
        System.out.println("hardDisk: " + hardDisk);
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建一个计算机对象
        Computer computer = new Computer(new IntelCpu("intel"), new ShanDiHardDisk("shanDi"));

        // 显示计算机的配件信息
        computer.show();
    }
}
```

**依赖倒置原则 是实现 开闭原则 的关键手段，开闭原则 是 依赖倒置原则 的应用目标之一。** 所以他们两个的例子基本一样



### 4. 里氏替换原则（LSP）

**定义**: 子类必须能够替换其父类，且不影响程序的正确性。

**核心思想**: 子类可以继承父类的行为，并在必要时扩展功能，但不能改变父类的预期行为

反面示例：

```java
// 父类 Bird 的 fly() 方法预期是鸟儿能飞。
// 子类 Ostrich 重写了 fly()，但完全改变了行为（抛异常），破坏了父类的契约。当 Ostrich 替换 Bird 时，程序出错，违反 LSP。
class Bird {
    public void fly() {
        System.out.println("I can fly!");
    }
} // 鸵鸟
class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("I can't fly!");
    }
}

class Main {
    public static void makeBirdFly(Bird bird) {
        bird.fly();  // 期望鸟儿飞，但 Ostrich 会抛异常
    }

    public static void main(String[] args) {
        makeBirdFly(new Bird());      // 正常
        makeBirdFly(new Ostrich());   // 抛异常，违反 LSP
    }
}
```

正面示例：

```java
// 父类 move() 定义了“移动”的行为，子类 Ostrich 重写为“在地上跑”，仍然符合“移动”的契约。
// 子类替换父类时，程序行为正常，符合 LSP。
class Bird {
    public void move() {
        System.out.println("I can move!");
    }
} // 鸵鸟
class Ostrich extends Bird {
    @Override
    public void move() {
        System.out.println("I can run on the ground!");
    }
}

class Main {
    public static void makeBirdMove(Bird bird) {
        bird.move();  // 无论 Bird 还是 Ostrich，都能正常移动
    }

    public static void main(String[] args) {
        makeBirdMove(new Bird());     // 输出: I can move!
        makeBirdMove(new Ostrich());  // 输出: I can run on the ground!
    }
}
```



### 5. 接口隔离原则（ISP）

**定义**: 客户端不应该被迫依赖它不使用的接口。

**核心思想**: 接口应小而专一，避免“胖接口”。

反面示例：

```java
// Worker 接口包含 eat() 方法，但 RobotWorker 不需要这个功能，却被迫实现。
// 如果 Worker 接口新增方法（如 sleep()），所有实现类都得修改，即使对机器人无意义。
interface Worker {
    void work();  // 工作
    void eat();   // 吃饭
}
class HumanWorker implements Worker {
    public void work() {
        System.out.println("Human working...");
    }

    public void eat() {
        System.out.println("Human eating...");
    }
}
class RobotWorker implements Worker {
    public void work() {
        System.out.println("Robot working...");
    }

    public void eat() {
        // 机器人不吃饭，空实现
        System.out.println("Robot doesn't eat.");
    }
}

public class Main {
    public static void main(String[] args) {
        Worker human = new HumanWorker();
        human.work();
        human.eat();

        Worker robot = new RobotWorker();
        robot.work();
        robot.eat();  // 无意义的调用
    }
}
```

正面示例：

```java
// Workable 和 Eatable 分离，RobotWorker 只实现 Workable，无需处理无关的 eat()。
// 如果新增 Sleepable 接口，只影响需要睡眠的类（如人类），机器人不受影响。
interface Workable {
    void work();
}
interface Eatable {
    void eat();
}
class HumanWorker implements Workable, Eatable {
    public void work() {
        System.out.println("Human working...");
    }

    public void eat() {
        System.out.println("Human eating...");
    }
}
class RobotWorker implements Workable {
    public void work() {
        System.out.println("Robot working...");
    }
    // 不需要实现 eat()
}

public class Main {
    public static void main(String[] args) {
        Workable humanWorker = new HumanWorker();
        humanWorker.work();

        Eatable humanEater = new HumanWorker();
        humanEater.eat();

        Workable robot = new RobotWorker();
        robot.work();  // 机器人只关心工作
    }
}
```





### 6. 最少知识原则（迪米特法则）

**定义**: 一个对象应尽量少了解其他对象的内部结构（“只与朋友说话”）。

**核心思想**: 减少对象间的直接调用，避免链式访问（如 a.getB().getC()）。

方面示例：

```java
// Shop 直接调用 customer.getWallet().getMoney()，深入了解了 Customer 的内部结构（Wallet）。
// 如果 Customer 改成用 BankCard 替代 Wallet，Shop 的代码也要改，耦合性高。
class Wallet {
    private int money;

    public int getMoney() {
        return money;
    }
}
class Customer {
    private Wallet wallet;

    public Wallet getWallet() {
        return wallet;
    }

    public Customer() {
        this.wallet = new Wallet();
    }
}
class Shop {
    public void sell(Customer customer) {
        int amount = customer.getWallet().getMoney();  // 链式调用
        System.out.println("Customer pay: " + amount);
    }
}

public class Main {
    public static void main(String[] args) {
        Customer customer = new Customer();
        Shop shop = new Shop();
        shop.sell(customer);
    }
}
```

正面示例：

```java
// Shop 不再关心 Customer 如何支付（是用 Wallet 还是其他方式），只调用 customer.pay()。
// 如果 Customer 内部实现变化（比如用 BankCard），Shop 无需修改。
class Wallet {
    private int money;

    public int getMoney() {
        return money;
    }
}

class Customer {
    private Wallet wallet;

    public Customer() {
        this.wallet = new Wallet();
    }

    // 增加代理方法，封装内部逻辑
    public int pay() {
        return wallet.getMoney();
    }
}

class Shop {
    public void sell(Customer customer) {
        int amount = customer.pay();  // 只与 Customer 交互
        System.out.println("Customer paid: " + amount);
    }
}

public class Main {
    public static void main(String[] args) {
        Customer customer = new Customer();
        Shop shop = new Shop();
        shop.sell(customer);
    }
}
```





### 7. 合成复用原则

定义: 优先使用组合或聚合而非继承来复用代码。

核心思想: 继承导致紧耦合，组合更灵活。

反面示例：

```java
// Car 继承 Engine，形成“Car 是一种 Engine”的关系，逻辑上不合理（Car 应该“拥有”Engine）。
// 如果 Engine 添加新方法（如 stop()），Car 会无意继承，增加不必要的功能。
// 无法动态更换引擎类型（比如换成电动引擎）。

class Engine {
    public void start() {
        System.out.println("Engine started.");
    }
}
class Car extends Engine {
    public void drive() {
        start();  // 继承来的方法
        System.out.println("Car is driving.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.drive();
    }
}
```

正面示例：

```java
class Engine {
    public void start() {
        System.out.println("Engine started.");
    }
}
class Car {
    private Engine engine;  // 组合关系

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving.");
    }

    // 可动态更换引擎
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}
class ElectricEngine {
    public void start() {
        System.out.println("Electric engine started.");
    }
}

public class Main {
    public static void main(String[] args) {
        Engine gasEngine = new Engine();
        Car car = new Car(gasEngine);
        car.drive();

        // 动态更换引擎
        ElectricEngine electricEngine = new ElectricEngine();
        car.setEngine(electricEngine);
        car.drive();
    }
}
```



## 二、软件(程序)设计模式

Java设计模式是软件开发中解决常见问题的一些经过验证的解决方案，它们是基于面向对象设计原则的最佳实践。设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。

### 1. 创建者模式

#### 1.1 单例设计模式

单例设计模式是说一个类不再提供构造方法，而是通过一个静态方法给外部提供实例，并且这个类只会创建一个实例，当创建过实例后，再次通过静态方法获取时，获取到的时创建过的。一般分为两种实现方式：**饿汉式**和**懒汉式**



**实现单例模式**

饿汉式是说在类加载的时候就创建了实例，懒汉式是说在类加载的时候并没有创建实例，而是当外部获取时创建。饿汉式一般通过 new或者静态代码块来实现，懒汉式如下：

1. 锁和双重检查法实现

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}  // 私有构造器

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
    
//    这种方式也可以，不过性能比较低，因为每次都会上锁
//    public static synchronized Singleton getInstance() {
//        if (instance == null) {
//            instance = new Singleton();
//        }
//        return instance;
//    }

    public void show() {
        System.out.println("Singleton instance: " + this);
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
        s1.show();
        System.out.println(s1 == s2);  // true
    }
}
```

2. 静态内部类实现

JVM只有在使用某个类时才会加载它，类加载是由JVM控制的，并且他是线程安全的

```java
public class Singleton {
    // 私有构造器，防止外部实例化
    private Singleton() {}

    // 静态内部类，持有单例实例
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // 公共方法获取实例
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    public void show() {
        System.out.println("Singleton instance: " + this);
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
        s1.show();
        System.out.println(s1 == s2);  // true
    }
}
```

**破坏单例模式**

序列化和反序列化，反射 可以破坏单例模式

1. 解决序列化反序列化破坏单例模式的方法：

```java
public class Singleton implements Serializable {
    // 实现这个方法，在反序列化时如果存在这个方法，会被调用，生成反序列化的对象
    public Object readResolve() {
        return instance;
    }
}
```

2. 解决反射破坏单例模式

```java
private Singleton() {
    synchronized {
        if (instance != null) {
            throw new RuntimeException("Singleton already instantiated!");
        }
    }
}
```





#### 1.2 工厂设计模式

工厂模式通过将对象的创建过程封装到工厂类中，隐藏实例化的细节，提供统一的创建接口。核心思想: 将“创建对象”与“使用对象”分离，增强灵活性和可扩展性。

实现方式主要有三种：

1. 简单工厂模式（非正式设计模式）
2. 工厂方法模式（经典设计模式）
3. 抽象工厂模式（复杂产品族模式）



**实现工厂模式**

1. 简单工厂模式

简单工厂模式通过一个工厂类，根据传入的参数创建不同的产品对象。它不属于 GoF 的 23 种经典设计模式，但常作为工厂模式的入门。

核心思想：一个工厂类负责所有产品的创建，客户端通过参数选择所需产品。

```java
interface Product {
    void use();
}
class ProductA implements Product {
    public void use() { System.out.println("Using Product A"); }
}
class ProductB implements Product {
    public void use() { System.out.println("Using Product B"); }
}

// 简单工厂, 违反开闭原则
class SimpleFactory {
    public static Product createProduct(String type) {
        if ("A".equals(type)) {
            return new ProductA();
        } else if ("B".equals(type)) {
            return new ProductB();
        }
        return null;
    }
}

public class Main {
    public static void main(String[] args) {
        Product productA = SimpleFactory.createProduct("A");
        Product productB = SimpleFactory.createProduct("B");
        productA.use();  // Using Product A
        productB.use();  // Using Product B
    }
}
```

2. 工厂方法模式（经典设计模式）

定义一个创建对象的接口，让子类（具体工厂）决定实例化哪个类，将对象的创建推迟到子类。（java中的Iterator就是一个对象的接口，在List工厂中创建了这个Iterator实现类）

核心思想：通过工厂接口和具体工厂分离创建职责，支持扩展。

```java
interface Product {
    void use();
}
class ProductA implements Product {
    public void use() { System.out.println("Using Product A"); }
}
class ProductB implements Product {
    public void use() { System.out.println("Using Product B"); }
}
interface Factory {
    Product createProduct();
}
class FactoryA implements Factory {
    public Product createProduct() { return new ProductA(); }
}

class FactoryB implements Factory {
    public Product createProduct() { return new ProductB(); }
}

public class Main {
    public static void main(String[] args) {
        Factory factoryA = new FactoryA();
        Product productA = factoryA.createProduct();
        productA.use();  // Using Product A

        Factory factoryB = new FactoryB();
        Product productB = factoryB.createProduct();
        productB.use();  // Using Product B
    }
}
```

3. 抽象工厂模式

提供一个接口，用于创建一系列相关或依赖的对象（产品族），无需指定具体类。

核心思想：生产一组相关产品，保证产品之间的兼容性。

```java
// 产品接口
interface Button { void render(); }
interface Checkbox { void check(); }

// 具体产品（Windows 产品族）
class WinButton implements Button { public void render() { System.out.println("Windows Button"); } }
class WinCheckbox implements Checkbox { public void check() { System.out.println("Windows Checkbox"); } }

// 具体产品（Mac 产品族）
class MacButton implements Button { public void render() { System.out.println("Mac Button"); } }
class MacCheckbox implements Checkbox { public void check() { System.out.println("Mac Checkbox"); } }

// 抽象工厂
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// 具体工厂
class WinFactory implements GUIFactory {
    public Button createButton() { return new WinButton(); }
    public Checkbox createCheckbox() { return new WinCheckbox(); }
}

class MacFactory implements GUIFactory {
    public Button createButton() { return new MacButton(); }
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}

public class Main {
    public static void main(String[] args) {
        GUIFactory winFactory = new WinFactory();
        Button winButton = winFactory.createButton();
        Checkbox winCheckbox = winFactory.createCheckbox();
        winButton.render();  // Windows Button
        winCheckbox.check(); // Windows Checkbox

        GUIFactory macFactory = new MacFactory();
        Button macButton = macFactory.createButton();
        Checkbox macCheckbox = macFactory.createCheckbox();
        macButton.render();  // Mac Button
        macCheckbox.check(); // Mac Checkbox
    }
}
```

**工厂模式的扩展**

根据配置文件或参数动态选择产品，增强灵活性。

```java
import java.util.Properties;

interface Product {
    void use();
}

class ProductA implements Product {
    public void use() { System.out.println("Using Product A"); }
}

interface Factory {
    Product createProduct();
}

class ConfigurableFactory implements Factory {
    private String productClass;	// 全类名，一般通过配置文件方式获取

    public ConfigurableFactory(String productClass) {
        this.productClass = productClass;
    }

    public Product createProduct() {
        try {
            Class<?> clazz = Class.forName(productClass);
            return (Product) clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create product", e);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // 模拟配置文件
        Properties config = new Properties();
        config.setProperty("product", "ProductA");
        String productClass = config.getProperty("product");

        Factory factory = new ConfigurableFactory(productClass);
        Product product = factory.createProduct();
        product.use();  // Using Product A
    }
}
```





#### 1.3 原型模式

 原型模式通过复制（克隆）一个已有对象来创建新对象，而不是通过构造器重新初始化。核心思想: 使用现有对象作为模板，通过复制其状态生成新对象，减少创建开销。

```java

```



#### 1.4 建造者模式





### 2. 结构性模式



### 3. 行为模式









